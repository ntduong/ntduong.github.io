<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Random Notes - Data structures</title><link href="/" rel="alternate"></link><link href="/feeds/data-structures.atom.xml" rel="self"></link><id>/</id><updated>2021-01-06T00:00:00+09:00</updated><entry><title>Binary Indexed Tree (Part 2)</title><link href="/binary-indexed-tree-part-2.html" rel="alternate"></link><published>2021-01-06T00:00:00+09:00</published><updated>2021-01-06T00:00:00+09:00</updated><author><name>Duong Nguyen</name></author><id>tag:None,2021-01-06:/binary-indexed-tree-part-2.html</id><summary type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Building on ideas from &lt;a href="https://ntduong.github.io/binary-indexed-tree-part-1.html"&gt;Part 1&lt;/a&gt;, in this part, we explore some lesser-known extensions and applications of BIT.&lt;/p&gt;
&lt;p&gt;This is by no means a finished post, and I'll keep updating whenever I find new BIT applications/extensions.&lt;/p&gt;
&lt;h1 id="variation-1-range-update-point-query"&gt;Variation 1: Range update, Point query&lt;/h1&gt;
&lt;p&gt;We want the data structure, which …&lt;/p&gt;</summary><content type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Building on ideas from &lt;a href="https://ntduong.github.io/binary-indexed-tree-part-1.html"&gt;Part 1&lt;/a&gt;, in this part, we explore some lesser-known extensions and applications of BIT.&lt;/p&gt;
&lt;p&gt;This is by no means a finished post, and I'll keep updating whenever I find new BIT applications/extensions.&lt;/p&gt;
&lt;h1 id="variation-1-range-update-point-query"&gt;Variation 1: Range update, Point query&lt;/h1&gt;
&lt;p&gt;We want the data structure, which supports the following operations on an input array &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;range_update(L, R, v)&lt;/code&gt;: increase all &lt;span class="math"&gt;\(a[L..R]\)&lt;/span&gt; by &lt;span class="math"&gt;\(v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;point_query(i)&lt;/code&gt;: return the current &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Recall from Part 1, normal BIT only supports range prefix queries and point updates. How are we going to implement point query, range update with existing operations?&lt;/p&gt;
&lt;p&gt;Consider the diff array &lt;code&gt;d[1..n]&lt;/code&gt;, &lt;code&gt;d[1] = a[1], d[i] = a[i]-a[i-1]&lt;/code&gt; for &lt;code&gt;i=2,...,n&lt;/code&gt;,
&lt;code&gt;a[i] = d[i] + d[i-1] + ... + d[1]&lt;/code&gt; for &lt;code&gt;i=1,...,n&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key idea is to use the basic range query-point update BIT on the &lt;strong&gt;diff array &lt;span class="math"&gt;\(d[1..n]\)&lt;/span&gt;&lt;/strong&gt; instead of the original array &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Clearly, &lt;code&gt;query(i)&lt;/code&gt; = &lt;code&gt;sum(d[1..i])&lt;/code&gt; = &lt;code&gt;a[i]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now think about the range update &lt;code&gt;u(L,R,v)&lt;/code&gt;, &lt;span class="math"&gt;\(a[i] \leftarrow a[i]+v\)&lt;/span&gt; for all &lt;span class="math"&gt;\(L \leq i \leq R\)&lt;/span&gt;, how does the diff array change with the update?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No change to &lt;span class="math"&gt;\(d[i]\)&lt;/span&gt; for any &lt;span class="math"&gt;\(i &amp;lt; L\)&lt;/span&gt;, &lt;span class="math"&gt;\(L+1 \leq i \leq R\)&lt;/span&gt;, &lt;span class="math"&gt;\(R+1 &amp;lt; i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(d[L] \leftarrow d[L] + v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(d[R+1] \leftarrow d[R+1] - v\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus we can achieve the range update &lt;code&gt;u(L,R,v)&lt;/code&gt; with two point updates:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;update(L,v)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update(R+1,-v)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See also my &lt;a href="https://github.com/ntduong/Algorithms/blob/master/data_structures/range_queries/bit_variants.cpp#L18"&gt;reference implementation&lt;/a&gt; in C++ if you're interested.&lt;/p&gt;
&lt;h1 id="variation-2-range-update-range-query"&gt;Variation 2: Range update, Range query&lt;/h1&gt;
&lt;p&gt;We want the data structure, which supports the following operations on an input array &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;range_update(L, R, v)&lt;/code&gt;: increase all &lt;span class="math"&gt;\(a[L..R]\)&lt;/span&gt; by &lt;span class="math"&gt;\(v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;range_query(i)&lt;/code&gt;: return the prefix sum up to &lt;span class="math"&gt;\(i\)&lt;/span&gt;, i.e., &lt;span class="math"&gt;\(\sum_{j=1}^i a[j]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We've seen above how range update can be implemented. Let see how prefix range queries at different &lt;span class="math"&gt;\(i\)&lt;/span&gt;s change after a &lt;code&gt;range_update(L,R,v)&lt;/code&gt;, let denote the change to &lt;code&gt;sum(a[1..i])&lt;/code&gt; as &lt;span class="math"&gt;\(\delta(i)\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i &amp;lt; L\)&lt;/span&gt;, &lt;span class="math"&gt;\(\delta(i) = 0 = 0 * i - 0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(L \leq i \leq R\)&lt;/span&gt;, &lt;span class="math"&gt;\(\delta(i) = (i-L+1) * v = v * i - (L-1) * v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i &amp;gt; R\)&lt;/span&gt;, &lt;span class="math"&gt;\(\delta(i) = (R-L+1) * v = 0 * i + R * v - (L-1) * v = 0 * i - ((L-1) * v - R * v)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note &lt;span class="math"&gt;\(\delta(i) = b(i) * i - c(i)\)&lt;/span&gt;. We can use 2 range update/point query BITs (the variation 1 above) to implement the range query and range update. The first BIT computes &lt;span class="math"&gt;\(b(i)\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$
b(i) = \left\{\begin{array}{ll}
0 &amp;amp; \text{if}~i &amp;lt; L \\
v &amp;amp; \text{if}~L \leq i \leq R \\
0 &amp;amp; \text{otherwise}
\end{array}\right.
$$&lt;/div&gt;
&lt;p&gt;The second BIT computes &lt;span class="math"&gt;\(c(i)\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$
c(i) = \left\{\begin{array}{ll}
0 &amp;amp; \text{if}~i &amp;lt; L \\
(L-1)*v &amp;amp; \text{if}~L \leq i \leq R \\
(L-1)*v - R*v &amp;amp; \text{otherwise}
\end{array}\right.
$$&lt;/div&gt;
&lt;p&gt;&lt;code&gt;range_update(L,R,v)&lt;/code&gt; can be implemented as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# bit1&lt;/span&gt;
&lt;span class="n"&gt;bit1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;point_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;bit1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;point_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# bit2&lt;/span&gt;
&lt;span class="n"&gt;bit2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;point_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;bit2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;point_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Also,
&lt;code&gt;range_query(i) = bit1.query(i) * i - bit2.query(i)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;See also my &lt;a href="https://github.com/ntduong/Algorithms/blob/master/data_structures/range_queries/bit_variants.cpp#L68"&gt;reference implementation&lt;/a&gt; in C++ if you're interested.&lt;/p&gt;
&lt;h1 id="2d-bit"&gt;2D BIT&lt;/h1&gt;
&lt;p&gt;Consider a 2D grid of size &lt;span class="math"&gt;\(H \times W\)&lt;/span&gt;, we want to support the following operations on the grid in &lt;span class="math"&gt;\(O(\log H * \log W)\)&lt;/span&gt; time:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;point_update(r,c,v)&lt;/code&gt;: increase the &lt;span class="math"&gt;\(g[r][c]\)&lt;/span&gt; by &lt;span class="math"&gt;\(v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;range_query(r1,r2,c1,c2)&lt;/code&gt;: return sum of elements in &lt;span class="math"&gt;\(g[r1..r2][c1..c2]\)&lt;/span&gt;, &lt;span class="math"&gt;\(r1 \leq r2, c1 \leq c2\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you may expect, the &lt;code&gt;point_update&lt;/code&gt; is a straightforward extension of the normal 1D BIT into 2D. The range query can be computed as:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;range_query(r1,r2,c1,c2) = range_query(1,r2,1,c2) - range_query(1,r2,1,c1-1) - range_query(1,r1-1,1,c2) + range_query(1,r1-1,1,c1-1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;See also &lt;a href="https://github.com/ntduong/Algorithms/blob/master/data_structures/range_queries/bit2d.cpp"&gt;my reference implementation&lt;/a&gt; in C++.&lt;/p&gt;
&lt;h1 id="inversion-counting"&gt;Inversion Counting&lt;/h1&gt;
&lt;p&gt;&lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt; is a permutation of &lt;span class="math"&gt;\(\{1,2...n\}\)&lt;/span&gt;. An inversion is a pair &lt;span class="math"&gt;\((i,j)\)&lt;/span&gt;, &lt;span class="math"&gt;\(1 \leq i &amp;lt; j \leq n\)&lt;/span&gt; such that &lt;span class="math"&gt;\(a[i] &amp;gt; a[j]\)&lt;/span&gt;. Count the number of inversions in &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key idea is use the values &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; as index in BIT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Below is an overly commented Python snippet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;count_inversion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;initialize&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;BIT&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="n"&gt;bit&lt;/span&gt;

  &lt;span class="n"&gt;inv_cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# bit.query(x) returns how many values added so far, which are smaller than x.&lt;/span&gt;
    &lt;span class="c1"&gt;# Thus i - bit.query(x) is the number of values added which are bigger than x.&lt;/span&gt;
    &lt;span class="n"&gt;inv_cnt&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;# It&amp;#39;s important to update after the query.&lt;/span&gt;
    &lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inv_cnt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id="order-statistic-tree"&gt;Order Statistic Tree&lt;/h1&gt;
&lt;p&gt;We need a set-like data structure, which supports the following operations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add(x)&lt;/code&gt;: add &lt;span class="math"&gt;\(x\)&lt;/span&gt; to the set&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete(x)&lt;/code&gt;: remove &lt;span class="math"&gt;\(x\)&lt;/span&gt; from the set if existed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;order_of(x)&lt;/code&gt;: count the number of elements in the set that are strictly less than &lt;span class="math"&gt;\(x\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find_by_order(k)&lt;/code&gt;: return the &lt;span class="math"&gt;\(k^{th}\)&lt;/span&gt; lowest element in the set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Constraint: all updates &lt;span class="math"&gt;\(x\)&lt;/span&gt; are in the range &lt;span class="math"&gt;\([1..N]\)&lt;/span&gt; for some integer &lt;span class="math"&gt;\(N\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Again, the trick here is to use the element value as index in BIT array, making use of the constraint that all element values are in the range &lt;span class="math"&gt;\([1..N]\)&lt;/span&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Data structures"></category><category term="Algorithm"></category><category term="Fenwick tree"></category></entry><entry><title>Binary Indexed Tree (Part 1)</title><link href="/binary-indexed-tree-part-1.html" rel="alternate"></link><published>2021-01-05T00:00:00+09:00</published><updated>2021-01-05T00:00:00+09:00</updated><author><name>Duong Nguyen</name></author><id>tag:None,2021-01-05:/binary-indexed-tree-part-1.html</id><summary type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Binary indexed tree (BIT for short), aka &lt;a href="https://en.wikipedia.org/wiki/Fenwick_tree"&gt;Fenwick tree&lt;/a&gt;, is popular data structure in competitive programming (CP)context. I strongly believe it's also a valuable tool to add to software developers' practical toolbox. But is it worth yet another BIT tutorial? Yes as my aim is to provide a …&lt;/p&gt;</summary><content type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Binary indexed tree (BIT for short), aka &lt;a href="https://en.wikipedia.org/wiki/Fenwick_tree"&gt;Fenwick tree&lt;/a&gt;, is popular data structure in competitive programming (CP)context. I strongly believe it's also a valuable tool to add to software developers' practical toolbox. But is it worth yet another BIT tutorial? Yes as my aim is to provide a different/new perspective on the data structure, complementing many existing (good) tutorials that I've seen. In particular, in this two-part series,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Part 1: Distill its core ideas with intuitive explanation provided when needed. If you're already familiar with the standard range-query/point-update BIT, feel free to skip this part.&lt;/li&gt;
&lt;li&gt;Part 2: Building on the core ideas from Part 1, suggest some flexible (and probably lesser-known) ways to extend the data structure to support more usecases, such as range-update/range-query and high-dimensional range queries.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Last but not least, BIT is one of my all-time favorite data structure, and the underlying ideas are beautiful so I decided to write about it for my future self!&lt;/p&gt;
&lt;h2 id="what-is-bit-anyway"&gt;What is BIT anyway?&lt;/h2&gt;
&lt;p&gt;In short, BIT is a data structure, supporting efficient range queries on &lt;strong&gt;dynamic&lt;/strong&gt; arrays, i.e., the array content can be updated along the way. More concretely, a standard BIT supports the following operations on an sized-&lt;span class="math"&gt;\(n\)&lt;/span&gt; array &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt; in &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; time per op, with additional &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; space (for internal structure):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prefix range query: &lt;span class="math"&gt;\(f(a[1..m])\)&lt;/span&gt;, e.g., sum of the first &lt;span class="math"&gt;\(m\)&lt;/span&gt; elements&lt;/li&gt;
&lt;li&gt;Point update: &lt;span class="math"&gt;\(u(a[i], v)\)&lt;/span&gt;, e.g., increasing &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; by &lt;span class="math"&gt;\(v\)&lt;/span&gt;, &lt;span class="math"&gt;\(a[i] \leftarrow a[i] + v\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are ways to enable (range update, point query) and (range update, range query) and they are all built on the key ideas that we're going to touch on later and in the next part.&lt;/p&gt;
&lt;p&gt;Despite its name and many existing tutorials describe it as a tree, I prefer to see BIT as a clever &lt;strong&gt;decomposition of the array&lt;/strong&gt; for efficient queries and updates. More about this will be discussed below.&lt;/p&gt;
&lt;p&gt;Honorable mentions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A more complex and powerful data structure which also support similar operations on dynamic arrays among other things is &lt;a href="https://cp-algorithms.com/data_structures/segment_tree.html"&gt;segment tree&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For range queries on &lt;strong&gt;static&lt;/strong&gt; arrays (no change to content), simpler data structures such as &lt;a href="https://cp-algorithms.com/data_structures/sparse-table.html"&gt;Sparse table&lt;/a&gt; (e.g., for range minimum query tasks), block decomposition techniques (e.g., &lt;a href="https://cp-algorithms.com/data_structures/sqrt_decomposition.html"&gt;square root decomposition&lt;/a&gt;), or even a simple prefix sum array would be enough.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'll write about these range-queries data structures in a future posts about beautiful and practical data structures (IMHO). So stay tuned!&lt;/p&gt;
&lt;h3 id="why-does-it-matter"&gt;Why does it matter?&lt;/h3&gt;
&lt;p&gt;Hang on, for the prefix range query and point update operations above, wouldn't the straightforward &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; update, &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; query on the array be enough? Why bother with BIT? Well, it depends, e.g.,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; update, &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; query approach is reasonable when most operations are update and very few are range query&lt;/li&gt;
&lt;li&gt;When the input size is large with many range queries then &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; query isn't ideal and &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; query at the expense of &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; update seems better&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Cliché: There is no single best solution for all usecases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="key-ideas"&gt;Key Ideas&lt;/h1&gt;
&lt;h2 id="range-decomposition"&gt;Range decomposition&lt;/h2&gt;
&lt;p&gt;For range query, without any preprocessing, the best we can do is to iterate over the whole range, which is essentially &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;. A natural idea is then to split the range into sub-ranges (smaller contiguous blocks) and "precompute" the queries on these blocks. To answer the query on the original range, we can just combine the precomputed answers on smaller sub-ranges.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key point is to devise efficient split and combine scheme.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Observation 1&lt;/strong&gt;: BIT splits a prefix range based on binary expansion.
Given a range &lt;span class="math"&gt;\(R = [1..m] = (0..m]\)&lt;/span&gt;, consider binary representation of &lt;span class="math"&gt;\(m = 2^{k_1} + 2^{k_2} + ... + 2^{k_t}\)&lt;/span&gt;, where &lt;span class="math"&gt;\(0 \leq k_1 \leq ... \leq k_t\)&lt;/span&gt;. Thus, 
&lt;/p&gt;
&lt;div class="math"&gt;$$
L = (0..2^{k_1}] \cup (2^{k_1}..(2^{k_1} + 2^{k_2})] \cup ...((2^{k_1}+...+2^{k_{t-1}})..m]
$$&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Clearly, all the subranges are disjoint and together (when union) they cover the whole original range.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;How do we quickly &lt;em&gt;traverse&lt;/em&gt; all these subranges?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Start with &lt;span class="math"&gt;\(m\)&lt;/span&gt; and remove the 1s to the right once at a time, starting from the least significant bit!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Example: &lt;span class="math"&gt;\(m = 7 = 2^2+2^1+2^0 = 111_{2}\)&lt;/span&gt;,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;remove the lsb: &lt;span class="math"&gt;\(7 (111) \rightarrow 6 (110)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;remove the next 1: &lt;span class="math"&gt;\(6 (110) \rightarrow 4(100)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;remove the last 1: &lt;span class="math"&gt;\(4(100) \rightarrow 0(000)\)&lt;/span&gt;
Hence, &lt;span class="math"&gt;\([1..7] = (0..7] = (0,4] \cup (4,6] \cup (6, 7]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The number of sub-ranges is the number of times the 1s are removed until we reach 0; which is the number of 1s in the binary representation of &lt;span class="math"&gt;\(m\)&lt;/span&gt;, which is at most &lt;span class="math"&gt;\(k_t \leq \log m\)&lt;/span&gt; (as &lt;span class="math"&gt;\(2^{k_t} \leq m\)&lt;/span&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can efficiently traverse and combine all the subranges of &lt;span class="math"&gt;\([1..n]\)&lt;/span&gt; in &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="remark"&gt;Remark&lt;/h3&gt;
&lt;p&gt;This &lt;strong&gt;binary expansion&lt;/strong&gt; (also known as &lt;strong&gt;binary lifting&lt;/strong&gt;) idea is so beautiful and I see it in many places (no surprise), such as RMQ (sparse table construction and non-idempotent query), finding lowest common ancestor (LCA), finding &lt;span class="math"&gt;\(k\)&lt;/span&gt;-node-away ancestor of a tree node, etc. For arrays of non-negatives (all prefix sums are non-decreasing), we can use this technique with BIT to find the prefix sum of a specific value in &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; time, same as binary search but no need for the array being sorted! I won't digress here and the binary lifting idea deserves its own post, for now see e.g., &lt;a href="https://codeforces.com/blog/entry/61364"&gt;this post&lt;/a&gt; if you're interested.&lt;/p&gt;
&lt;h3 id="implementation-details"&gt;Implementation details&lt;/h3&gt;
&lt;p&gt;Given a range &lt;span class="math"&gt;\((1..n]\)&lt;/span&gt;, it's fairly easy to implement the range query by iteratively extract and remove the least significant bit from &lt;span class="math"&gt;\(n\)&lt;/span&gt;. Recall modern computer system uses the &lt;a href="https://en.wikipedia.org/wiki/Two%27s_complement"&gt;two's conplement&lt;/a&gt; representation for integers, it's easy to see &lt;span class="math"&gt;\(2^{\text{lsb}(n)} = n \&amp;amp; (-n)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Let &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt; denote the query value computed on the range &lt;span class="math"&gt;\((i-(i\&amp;amp;-i)..i]\)&lt;/span&gt; (we'll get to how to update these &lt;span class="math"&gt;\(tree[1..n]\)&lt;/span&gt; later). In the code below, &lt;span class="math"&gt;\(tree[i] := sum(a[1..i])\)&lt;/span&gt; for prefix sum queries as an example, but the definition of &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt; is really problem-specific and we can adapt the logic to other kinds of query like &lt;span class="math"&gt;\(\text{xor}, \text{min}, \text{max}\)&lt;/span&gt;, etc when fitted. &lt;em&gt;Be creative!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Overly commented code snippet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;Returns sum(a[1..i]), 1 &amp;lt;= i &amp;lt;= n.&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

  &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# replace += with other combination ops for specific problems at hand&lt;/span&gt;
    &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="c1"&gt;# remove lsb to traverse to next subrange&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ans&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Generally, BIT only supports prefix range queries, but for specific cases such as range sum or xor we can query any range:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Range sum: &lt;span class="math"&gt;\(sum(a[L..R]) = query(R) - query(L-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Range XOR: &lt;span class="math"&gt;\(\text{xor}(a[L..R]) = query(R)~\text{xor}~ query(L-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="update-relevant-ranges"&gt;Update relevant ranges&lt;/h2&gt;
&lt;p&gt;We now get to point update operation, &lt;span class="math"&gt;\(u(a[i],v)\)&lt;/span&gt;. As mentioned above, &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt; stores the current value computed on its corresponding range &lt;span class="math"&gt;\((i-2^{\text{lsb}(i)}..i]\)&lt;/span&gt;. In other words, &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt; is responsible for the range&lt;span class="math"&gt;\( (i-2^{\text{lsb}(i)}..i]\)&lt;/span&gt;. Thus an update to any element in the range needs to "inform" and update &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt;. Flip it around, for an update &lt;span class="math"&gt;\(u(a[i], v),\)&lt;/span&gt; we need to update all relevant ranges to which &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; belongs!&lt;/p&gt;
&lt;p&gt;Denote &lt;span class="math"&gt;\(R_j = (j-2^{\text{lsb}(j)}..j]\)&lt;/span&gt;,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Claim 1: &lt;span class="math"&gt;\(R_i, R_{i+\text{lsb}(i)}...\)&lt;/span&gt; are the only ranges to which &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; belong.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For example, given array &lt;span class="math"&gt;\(a[1..8]\)&lt;/span&gt;, what ranges covering &lt;span class="math"&gt;\(a[3]\)&lt;/span&gt;?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(R_3 = (2..3]\)&lt;/span&gt;, &lt;span class="math"&gt;\(R_4 = (0..4]\)&lt;/span&gt;, &lt;span class="math"&gt;\(R_8 = (0..8]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Not convinced yet? Here is a proof sketch, which also gives some insights into the BIT structure.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma 1&lt;/strong&gt;: &lt;span class="math"&gt;\(R_i \subset R_{i+\text{lsb}(i)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Proof:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{lsb}(i) \leq 0 \Rightarrow j = i+\text{lsb}(i) \geq i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{lsb}(j) \geq \text{lsb}(i) +1 \Rightarrow 2^{\text{lsb}(j)} \geq 2*2^{\text{lsb}(i)} \Rightarrow j-2^{\text{lsb}(j)} \leq j-2*2^{\text{lsb}(i)} = i+2^{\text{lsb}(i)}-2*2^{\text{lsb}(i)} = i-2^{\text{lsb}(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lemma 1 shows that &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; belongs to &lt;span class="math"&gt;\(R_i, R_{i+\text{lsb}(i)}...\)&lt;/span&gt;. Next let see why these ranges are the only ones covering &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma 2&lt;/strong&gt;: For all &lt;span class="math"&gt;\(j\)&lt;/span&gt; such that &lt;span class="math"&gt;\(i &amp;lt; j &amp;lt; i+2^{\text{lsb}(i)}\)&lt;/span&gt;, &lt;span class="math"&gt;\(i \notin R_j\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Proof:&lt;/p&gt;
&lt;p&gt;Note that we only consider even &lt;span class="math"&gt;\(i\)&lt;/span&gt;, since for odd &lt;span class="math"&gt;\(i\)&lt;/span&gt;, &lt;span class="math"&gt;\(i+2^{\text{lsb}(i)} = i+1\)&lt;/span&gt;, and there is no integer &lt;span class="math"&gt;\(j \in (i,i+1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(j\)&lt;/span&gt; is odd, clearly &lt;span class="math"&gt;\(i \notin R_j = (j-1,j]\)&lt;/span&gt; since &lt;span class="math"&gt;\(i \leq j-1\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(j\)&lt;/span&gt; is even, &lt;span class="math"&gt;\(k = j-i\)&lt;/span&gt; is even, and &lt;span class="math"&gt;\(k &amp;lt; 2^{\text{lsb}(i)}\)&lt;/span&gt;, thus &lt;span class="math"&gt;\(2^{\text{lsb}(k)} &amp;lt; 2^{\text{lsb}(i)}\)&lt;/span&gt;. Hence, &lt;span class="math"&gt;\(\text{lsb}(k)\)&lt;/span&gt; is also &lt;span class="math"&gt;\(\text{lsb}(j)\)&lt;/span&gt;. &lt;span class="math"&gt;\(j-2^{\text{lsb}(j)} = j-2^{\text{lsb}(k)} \geq j-k = i\)&lt;/span&gt;, i.e., &lt;span class="math"&gt;\(i \notin R_j = (j-2^{\text{lsb}(j)}, j]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now apply Lemma 2 to &lt;span class="math"&gt;\(i' = i+\text{lsb}(i)\)&lt;/span&gt;, &lt;span class="math"&gt;\(\forall j \in (i', i' + \text{lsb}(i')\)&lt;/span&gt;, &lt;span class="math"&gt;\(i' \notin R_j\)&lt;/span&gt; and follows &lt;span class="math"&gt;\(i \notin R_j\)&lt;/span&gt; since &lt;span class="math"&gt;\(i &amp;lt; i'\)&lt;/span&gt;. Repeating this process, we can prove the claim that &lt;span class="math"&gt;\(R_i, R_{i+\text{lsb}(i)},...\)&lt;/span&gt; are the only ranges covering &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; (QED)!&lt;/p&gt;
&lt;h3 id="implementation-details_1"&gt;Implementation details&lt;/h3&gt;
&lt;p&gt;With the above claim, it's trivia to implement the update. As an example, this is the snippet for increment update &lt;span class="math"&gt;\(a[i] \leftarrow a[i] + v\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Claim 2: There is at most &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; ranges covering &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; for &lt;span class="math"&gt;\(1 \leq i \leq n\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The while loop continues until &lt;span class="math"&gt;\(i\)&lt;/span&gt; goes beyond &lt;span class="math"&gt;\(n\)&lt;/span&gt;. Every iteration update &lt;span class="math"&gt;\(i \leftarrow i + 2^{\text{lsb}(i)}\)&lt;/span&gt;, i.e., it moves the LSB at least one position to the left. Thus there can be at most &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; iterations, and the update op is &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; time, assuming the increment is &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h1 id="recap"&gt;Recap&lt;/h1&gt;
&lt;p&gt;In this part, we explore key ideas of BIT:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Split range into disjoint subranges based on binary expansion for efficient range query&lt;/li&gt;
&lt;li&gt;For each point update, we need to update all the ranges covering the point. This is a tradeoff to speed up the range query&lt;/li&gt;
&lt;li&gt;No single best solution for all usecases. BIT is efficient for large input size with a lot of range queries&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;https://cp-algorithms.com/data_structures/fenwick.html&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.topcoder.com/community/competitive-programming/tutorials/binary-indexed-trees/"&gt;Topcoder's excellent tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Data structures"></category><category term="Algorithm"></category><category term="Fenwick tree"></category></entry></feed>