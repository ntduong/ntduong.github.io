<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Random Notes - Duong Nguyen</title><link href="/" rel="alternate"></link><link href="/feeds/duong-nguyen.atom.xml" rel="self"></link><id>/</id><updated>2021-02-14T00:00:00+09:00</updated><entry><title>An opinionated case against A/B testing: Exploration-vs-Exploitation</title><link href="/an-opinionated-case-against-ab-testing-exploration-vs-exploitation.html" rel="alternate"></link><published>2021-02-14T00:00:00+09:00</published><updated>2021-02-14T00:00:00+09:00</updated><author><name>Duong Nguyen</name></author><id>tag:None,2021-02-14:/an-opinionated-case-against-ab-testing-exploration-vs-exploitation.html</id><summary type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Nowadays, a lot of companies (esp. tech companies) have been embracing data-driven decision making practice. Almost every business decision such as &lt;em&gt;what background color should be used for the company website&lt;/em&gt; or &lt;em&gt;whether a new kitty photo filter should be released&lt;/em&gt; requires justification with some performance metrics. A/B â€¦&lt;/p&gt;</summary><content type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Nowadays, a lot of companies (esp. tech companies) have been embracing data-driven decision making practice. Almost every business decision such as &lt;em&gt;what background color should be used for the company website&lt;/em&gt; or &lt;em&gt;whether a new kitty photo filter should be released&lt;/em&gt; requires justification with some performance metrics. A/B testing has become a de facto tool for trying out and &lt;strong&gt;comparing&lt;/strong&gt; multiple ideas/solutions (aka, &lt;em&gt;arms&lt;/em&gt;, &lt;em&gt;options&lt;/em&gt;) simultaneously, often &lt;strong&gt;on production user traffic&lt;/strong&gt;, such as user requests. In business, A/B testing is a general term referring to the practice of conducting randomized controlled trials (aka, &lt;em&gt;experiment&lt;/em&gt;) on real/production users. &lt;/p&gt;
&lt;h2 id="a-simple-ab-test"&gt;A simple A/B test&lt;/h2&gt;
&lt;p&gt;Let's consider an oversimplified A/B test on a company homepage background color, in which we want to decice which color, &lt;em&gt;red&lt;/em&gt; or &lt;em&gt;blue&lt;/em&gt; should be used. Say the CEO agrees to give me 20% of website traffic to experiment on for 1 month. I then get a fair coin with 50% chance of turning up head/tail. Whenever a user request comes, I flip the coin, if it's head then the user gets to see &lt;em&gt;red&lt;/em&gt;; otherwise the user gets to see &lt;em&gt;blue&lt;/em&gt;. This process applies up to 20% traffic at a time. I also need to decide key performance metrics to be measured on experimental traffic. Let's pretend for a user comes to the website, I want to measure their engagement/happiness with the background color in terms of the duration they stay on the site (in minutes); the longer the happier the better. After 1 month, I compare the average happiness scores of the red and blue groups and turns out the red group has the higher score. I draw conclusion that red is better and propose red color to the CEO (final decision maker). That's it, a simple yet typical example of an A/B test.&lt;/p&gt;
&lt;h2 id="more-boring-details"&gt;More (boring) details&lt;/h2&gt;
&lt;p&gt;A typical A/B test usually includes a single baseline (aka &lt;strong&gt;Control group&lt;/strong&gt;) and 1 or more experimental arms (aka &lt;strong&gt;Treatment groups&lt;/strong&gt;).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Treatment arms and Control represent different options we'd like to try out and compare; but other than that they are under kept similar (hence, &lt;em&gt;controlled&lt;/em&gt;). A treatment arm is usually compared against the Control and/or other treatment arms, in terms of key performance metrics.&lt;/li&gt;
&lt;li&gt;What metrics should be used depend on specific business problems, such as click-through-rate (CTR) on ads banner, user visit rate on website etc.&lt;/li&gt;
&lt;li&gt;How much traffic should be used: usually companies can't afford running experiments on large production traffic (except when they are inevitably neccessary); lest a significant part of users will be treated weird/sub-optimal experience (ahem, it's an experimental feature anyway!). It's crucial to have a &lt;strong&gt;representative&lt;/strong&gt; traffic for experiment; since we want to draw business insights/conclusion from the experimental traffic and extrapolate to full production user traffic.&lt;/li&gt;
&lt;li&gt;How long should a A/B test run? It again depends on specific problems and domains, but short to medium-term (up to 1 month) experiments are very common.&lt;/li&gt;
&lt;li&gt;Experiment sizing (how much traffic, how long to run) is critical to the success of a test. The sizing needs to be done carefully with statistical rigor before starting the test. Once it's decided, it should be kept until the end; modifying these midway essentially invalidate the experiment results (e.g., some p-hacking tricks like extending test duration or increase traffic midway are unacceptable!)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A/B testing isn't new or exotic tool at all, in fact a lot of A/B tests (aka, &lt;strong&gt;experiment&lt;/strong&gt;) have been conducted daily by e.g., scientists, for drug testing, discovering new materials, chemical substances, new vaccinces, testing new medical treatments etc. With all due respect to the rigorous science of A/B testing, I believe it's pretty solid and reasonable tool for decision making. &lt;/p&gt;
&lt;p&gt;In this post, however &lt;strong&gt;I want to make a case agains A/B testing, that it is NOT a silver bullet, and may not work well in many practical scenarios&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id="when-ab-testing-fails"&gt;When A/B testing fails&lt;/h1&gt;
&lt;p&gt;Let's revisit the &lt;em&gt;simple&lt;/em&gt; red-or-blue example above. You may notice some naivety in my conclusion that red is better color. With just 1 month of data, how dare are you to conclude that red is better than blue? Turns out the experiment was running in the Christmas season and people seemed to prefer red (who doesn't like red-and-white Santa Claus with big presents :)), and somehow people seeing red stayed on the website longer, and tilted my happiness metric into red's favor. Sadly, soon after the Christmas season was over, the traffic to the red homepage went down drastically and many users voiced their concern/disastifaction with the red color! &lt;/p&gt;
&lt;p&gt;So you see the first flaw with short/mid-term A/B test: &lt;em&gt;some counfounding factors (out of experimenter's control?) can corrupt the performance metrics and lead to wrong conclusion, in hindsight&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;As a diehard A/B tester, I argue what if I was allowed to run the experiment for longer, say a full year, I'd surely figure out the best color. No way I can get approval for that given the clear risk of losing out users. But even if I can run the experiment for that long, I may end up observing no significant difference between red and blue in key metrics. How come? Turns out &lt;strong&gt;in hindsight again&lt;/strong&gt;, people prefer red during winter and fall; and blue during autumn and summer. Another possible scenario is user base shift over time, when the experiment starts, more users prefer red over blue, but somehow during the year, more blue users come and red users leave. So averaging over the whole year, blue and red are comparable, each has its own good and bad periods. Just by observing the results in the end, no conclusion can be draw on what color is better.&lt;/p&gt;
&lt;h2 id="the-key-assumption-of-ab-testing"&gt;The key assumption of A/B testing&lt;/h2&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The key underlying assumption of A/B testing is that there is a single winner, applicable to all user traffic over long time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;When this assumption holds, A/B testing works really well and help us figure out the clear winner quickly. But how often does this assumption hold true in practice? Many real-world interesting/critical problems don't have a single clear winner solution for all users, not to mention over long time. It's arguably more often that we're in the situation when different user groups prefer different solutions and working solutions shift over time. &lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;In other words, multiple solutions should co-exist and serve their own user base over time!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Even when A/B testing works well (and there exists a single clear winner), it still has an critical drawback; that is &lt;strong&gt;during experimental phase, a significant part of users are exposed to sub-optimal solutions&lt;/strong&gt;; since A/B testing usually divides up traffic into equal groups, and only one group gets the winner treatment.&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;This situation incurs &lt;strong&gt;regret&lt;/strong&gt;, loss of opportunity for the experiment runner (failed to deliver best experience to users) and sub-optimial experience hurts users and may turn them away from the business.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;So what are alternatives to A/B testing when it failed? Actually to be fair, the problem with A/B testing is more about how we interpret and make decision based on the experiment results; not the experiment itself (experimentation is good!). It's often that after a short period of exploring multiple options equally, a single option is selected to be the winner and then to be deployed to all traffic.&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;It's &lt;strong&gt;explore-then-exploit&lt;/strong&gt; (aka, explore-then-commit) strategy, nothing more!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;The problem is that we commit (too soon) to a single solution over long term for all users; which is usually sub-optimal. Thus, a natural alternative is to keep all options &lt;strong&gt;proportionally to how good individual options are&lt;/strong&gt;, i.e., keep good balance between exploration and exploitation!&lt;/p&gt;
&lt;h1 id="explore-vs-exploit"&gt;Explore vs Exploit&lt;/h1&gt;
&lt;p&gt;The exploration-vs-exploitation tradeoff is at the core of sequential decision making. In order to perform well over a long run, it's critical to juggle exploration and exploitation effectively. We need a flexible strategy which can adapt to the dynamics of the environment in which the strategy operates on. Too abstract? Let's revisit the red-or-blue problem, instead of committing to red after the experiment, what if we keep serving both red and blue; but with &lt;strong&gt;a catch&lt;/strong&gt;: the corresponding traffic should be proportional to how good a color currently performs, i.e., when red is doing better (based on user happiness metric), we should allocate more traffic to red than blue; and vice versa (when blue is doing better). &lt;strong&gt;The key here is the traffic for each option is scaled dynamically over time according to user preference&lt;/strong&gt;; the better a color performs, the higher traffic it receives. This sounds too good to be true; how can we do this? One popular approach to situations involving explore-vs-exploit across multiple options is the so-called &lt;a href="https://en.wikipedia.org/wiki/Multi-armed_bandit"&gt;&lt;strong&gt;multi-armed bandits&lt;/strong&gt;&lt;/a&gt;, which is a family of algorithms for decision making with strong theoretical support and empirical successes. Multi-armed bandits are a key ingredient in a lot of successful real-world applications, such as Netflix art work recommendation, website optimization, ads optimization. A detailed treatment of multi-armed bandits algorithms is obviously out of scope of this post; please refer to the References section for good resource on the topic.&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The key point to remember here is that multi-armed bandits allow for continuously exploring multiple options while exploiting best performers at a time. The exploration is proportional to individual options' performance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Astute readers may wonder how to incorporate contextual information, such as user profile into the decision making here in addition to solely relying on performance metrics. Yes, &lt;strong&gt;contextual bandits&lt;/strong&gt; is an algorithm in the multi-armed bandits family, taking into account contextual information when determining which option to take at a time for a particular context. For example, for a user with strong preference and watch history of anime, the algorithm should probably explore anime for this user, even though anime genre doesn't perform as well as other genres (like romantic drama) at the time.&lt;/p&gt;
&lt;p&gt;So should we abandon A/B testing for multi-armed bandits? It likely depends on your specific problems.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A/B testing enables decision making based on short-term experiments; with &lt;code&gt;explore equally-then-commit&lt;/code&gt; strategy&lt;/li&gt;
&lt;li&gt;OTOH, multi-armed bandits is always-on, continuously running experiment, in which multiple options are explored proportionally and best options at a time are exploited accordingly; essentionally &lt;code&gt;explore-vs-exploit&lt;/code&gt; juggling strategy. It sounds like a great strategy but comes with a cost for the balancing act. Devising good explore-vs-exploit balancing strategy in general is still an active research problem&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="middle-ground-proposal"&gt;Middle ground Proposal&lt;/h1&gt;
&lt;p&gt;Despite its limitation, A/B testing remains a widely adopted practice thanks to its working well and comparatively low cost (vs. multi-armed bandits) in practice. To end this long post, I want to propose some middle ground approach, taking into account the explore-vs-exploit trade-off.&lt;/p&gt;
&lt;h2 id="proposal-1-continuously-experiment-and-reevaluate-the-status-quo-to-search-for-the-better"&gt;Proposal 1: Continuously experiment and reevaluate the status-quo to search for the better&lt;/h2&gt;
&lt;p&gt;Committing to a single winner in short-term is reasonable; it's like accepting your local optimum with low cost. However, we should avoid sticking to a single winner for too long. Instead, a good strategy is to continuously run short A/B tests to reevaluate the status-quo and promote new better options when appropriate.&lt;/p&gt;
&lt;h2 id="proposal-2-incorporate-simple-exploration-strategy-in-addition-to-exploiting-the-current-best-option"&gt;Proposal 2: Incorporate simple exploration strategy in addition to exploiting the current best option&lt;/h2&gt;
&lt;p&gt;Consider adopting simple exploration strategy from multi-armed bandits literature:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt;-greedy: While commiting to the current best solution most of the time; we should set aside a small budget for random exploration, say for 5% of the time serving a &lt;code&gt;not-the-current-best&lt;/code&gt; solution&lt;/li&gt;
&lt;li&gt;Upper confidence bound (UCB): Explore an option proportionally to how much we know about its performance. Intuitively, the less we know about an option, the higher potential value it can bring (to our surprise); so we should try it more. Reversely, as we know more about an option, we may reduce its frequency. &lt;code&gt;Essentially, explore to reduce the entropy&lt;/code&gt;!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.oreilly.com/library/view/bandit-algorithms-for/9781449341565/"&gt;Bandits Algorithms for Website Optimization&lt;/a&gt;: a old yet good enough introductory book on basic bandits algorithms.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cambridge.org/core/books/bandit-algorithms/8E39FD004E6CE036680F90DD0C6F09FC"&gt;Bandits Algorithms&lt;/a&gt;: an excellent book with rigorous theoretical treatment of bandits algorithms by Tor Lattimore and Csaba SzepesvÃ¡ri.&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Decision Making"></category><category term="experiment"></category><category term="A/B test"></category><category term="multi-armed bandits"></category><category term="exploration"></category><category term="exploitation"></category></entry><entry><title>Bellman-Ford and systems of difference constraints</title><link href="/bellman-ford-and-systems-of-difference-constraints.html" rel="alternate"></link><published>2021-01-23T00:00:00+09:00</published><updated>2021-01-23T00:00:00+09:00</updated><author><name>Duong Nguyen</name></author><id>tag:None,2021-01-23:/bellman-ford-and-systems-of-difference-constraints.html</id><summary type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Bellman-Ford is an algorithm for finding shortest paths from a single source vertex to multiple target vertices in a weighted graph &lt;span class="math"&gt;\(G(V,E)\)&lt;/span&gt; whose edge weights can be negative. The algorithm can also detect negative cycle (if any) in the graph. Its time complexity is &lt;span class="math"&gt;\(O(|V|*|E â€¦&lt;/span&gt;&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Bellman-Ford is an algorithm for finding shortest paths from a single source vertex to multiple target vertices in a weighted graph &lt;span class="math"&gt;\(G(V,E)\)&lt;/span&gt; whose edge weights can be negative. The algorithm can also detect negative cycle (if any) in the graph. Its time complexity is &lt;span class="math"&gt;\(O(|V|*|E|)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;This post is, however, about a lesser-known application of the algorithm, namely solving a system of difference constraints of &lt;span class="math"&gt;\(n\)&lt;/span&gt; variables &lt;span class="math"&gt;\(\{x_i\}_{i=1}^n\)&lt;/span&gt; and &lt;span class="math"&gt;\(m\)&lt;/span&gt; constraints of the form: &lt;span class="math"&gt;\(x_j - x_i \leq w_{ij}\)&lt;/span&gt;, in &lt;span class="math"&gt;\(O(m*n)\)&lt;/span&gt; time complexity.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Note that this problem can be formulated as &lt;span class="math"&gt;\(A x \leq w\)&lt;/span&gt;, in which &lt;span class="math"&gt;\(x\)&lt;/span&gt; is the &lt;span class="math"&gt;\(n\)&lt;/span&gt;-vector of &lt;span class="math"&gt;\(\{x_1,...x_n\}\)&lt;/span&gt;, &lt;span class="math"&gt;\(w\)&lt;/span&gt; is the &lt;span class="math"&gt;\(m\)&lt;/span&gt;-vector of corresponding constraints, &lt;span class="math"&gt;\(A\)&lt;/span&gt; is a &lt;span class="math"&gt;\(m \times n\)&lt;/span&gt; matrix such that each row contains exactly one 1 and one -1 and 0 otherwise. We need to either find &lt;span class="math"&gt;\(x\)&lt;/span&gt; satisfies the inequality, or report that no solution exists, i.e., the constraints are unsatisfiable!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Wait a minute, I want a real-world problem, not a toy, theoretical one! Sure, you can find systems of difference constraints in many practical problems. For example, consider task scheduling with precedence constraints, in which we have &lt;span class="math"&gt;\(n\)&lt;/span&gt; tasks,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(x_i\)&lt;/span&gt; is the starting time of the &lt;span class="math"&gt;\(i^{th}\)&lt;/span&gt; task&lt;/li&gt;
&lt;li&gt;constraints: a task &lt;span class="math"&gt;\(i\)&lt;/span&gt; needs to be finished before starting a task &lt;span class="math"&gt;\(j\)&lt;/span&gt;, i.e., &lt;span class="math"&gt;\(x_i + \text{duration}(i)\leq x_j \Rightarrow x_i - x_j \leq -\text{duration}(u)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, it turns out we can find a solution that minimizes the spread of time of all tasks &lt;span class="math"&gt;\(\max_i x_i - \min_i x_i\)&lt;/span&gt; with the algorithm described below. &lt;/p&gt;
&lt;p&gt;Another example is in VLSI layout design, making chip layout as compact as possible while keeping required distances between components for reasonable performance.&lt;/p&gt;
&lt;p&gt;Convinced? So let's dive in!&lt;/p&gt;
&lt;h1 id="observation"&gt;Observation&lt;/h1&gt;
&lt;p&gt;Following are key observations, which suggest surprising connection between the shortest-path problem and the system of difference constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(x_j - x_i \leq w_{ij} \Rightarrow x_j \leq x_i + w_{ij}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;recall the relaxation often used in the shortest-path problem, &lt;span class="math"&gt;\(d_i, d_j\)&lt;/span&gt; are the shortest path from the source &lt;span class="math"&gt;\(s\)&lt;/span&gt; to vertices &lt;span class="math"&gt;\(i, j\)&lt;/span&gt; respectively, &lt;span class="math"&gt;\(w_{ij}\)&lt;/span&gt; is the weight of edge &lt;span class="math"&gt;\(i \rightarrow j\)&lt;/span&gt; (assume existed), then &lt;span class="math"&gt;\(d_j \leq d_i + w_{ij}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="constraint-graph"&gt;Constraint graph&lt;/h2&gt;
&lt;p&gt;Let's convert the system of difference constraints into a graph:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(n\)&lt;/span&gt; vertices corresponding to &lt;span class="math"&gt;\(n\)&lt;/span&gt; variables &lt;span class="math"&gt;\(\{x_i\}_{i=1}^n\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;for each constraint &lt;span class="math"&gt;\(x_j - x_i \leq w_{ij}\)&lt;/span&gt;, add an edge &lt;span class="math"&gt;\(i \rightarrow j\)&lt;/span&gt; with weight &lt;span class="math"&gt;\(w_{ij}\)&lt;/span&gt;. There are &lt;span class="math"&gt;\(m\)&lt;/span&gt; edges in total.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The resulting graph is the constraint graph corresponding to the original system of difference constraints.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Claim 1&lt;/strong&gt;: If there exists a negative cycle in the constraint graph, then the original system is unsatisfiable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Assume there exists a solution to the original system and a negative cycle &lt;span class="math"&gt;\(x_1 \rightarrow x_2 \rightarrow ... \rightarrow x_k \rightarrow x_1\)&lt;/span&gt;, i.e.,
&lt;span class="math"&gt;\(w_{12} + ... + w_{k1} &amp;lt; 0\)&lt;/span&gt;. However, &lt;span class="math"&gt;\(w_{12} + ... + w_{k1} = x_2 - x_1 + ... + x_1-x_k = 0\)&lt;/span&gt;. This is contradiction, hence Claim 1 is proved.&lt;/p&gt;
&lt;p&gt;Here comes Bellman Ford algorithm, helping us detect if any negative cycle in the constraint graph. If there is, then Claim 1 tells us that the system is unsatisfiable. &lt;/p&gt;
&lt;h2 id="extend-the-constraint-graph"&gt;Extend the constraint graph&lt;/h2&gt;
&lt;p&gt;Here we assume no negative cycle in the constraint graph (judged by Bellman Ford algorithm), then how can we find a solution to the constraint system? &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key idea is to add a new vertex &lt;span class="math"&gt;\(s\)&lt;/span&gt; to the constraint graph and &lt;span class="math"&gt;\(n\)&lt;/span&gt; edges of &lt;strong&gt;weight 0&lt;/strong&gt; from &lt;span class="math"&gt;\(s\)&lt;/span&gt; to all existing vertices. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Adding weight-0 edges to the graph doesn't introduce any negative cycle, and guarantee there are shortest paths from &lt;span class="math"&gt;\(s\)&lt;/span&gt; to all &lt;span class="math"&gt;\(n\)&lt;/span&gt; vertices &lt;span class="math"&gt;\(\{x_i\}_{i=1}^n\)&lt;/span&gt;. Let &lt;span class="math"&gt;\(\{d_i\}_{i=1}^n\)&lt;/span&gt; denote the corresponding shortest distances. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Claim 2: &lt;span class="math"&gt;\(\{d_i\}_{i=1}^n\)&lt;/span&gt; satisfies the difference constraints, and thus is a solution of the original system&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is mostly obvious given the triangle inequality (aka relaxation constraint) &lt;span class="math"&gt;\(d_j \leq d_i + w_{ij}\)&lt;/span&gt;.&lt;/p&gt;
&lt;h1 id="algorithm"&gt;Algorithm&lt;/h1&gt;
&lt;p&gt;To solve a difference constraint system, we can just:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Construct the corresponding constraint graph, extended with a source vertex &lt;span class="math"&gt;\(s\)&lt;/span&gt; (as mentioned above)&lt;/li&gt;
&lt;li&gt;Then run Bellman-Ford on the resulting graph to obtain shortest distances from &lt;span class="math"&gt;\(s\)&lt;/span&gt; to the remaining vertices&lt;/li&gt;
&lt;li&gt;If a negative cycle is detected, report no solution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The time complexity of this algorithm is &lt;span class="math"&gt;\(O(m*n)\)&lt;/span&gt;, thanks to the Bellman-Ford algorithm. &lt;/p&gt;
&lt;h2 id="implementation"&gt;Implementation&lt;/h2&gt;
&lt;p&gt;See my &lt;a href="https://github.com/ntduong/Algorithms/blob/master/graph/bf1.cpp"&gt;simple implementation&lt;/a&gt; of the Bellman-Ford algorithm.&lt;/p&gt;
&lt;h2 id="remark"&gt;Remark&lt;/h2&gt;
&lt;p&gt;There are cool properties of the solution found by the Bellman-Ford algorithm, which are worth mentioning:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;minimizes&lt;/strong&gt; &lt;span class="math"&gt;\(\max_i x_i - \min_i x_i\)&lt;/span&gt;, i.e., it minimizes the &lt;em&gt;spread&lt;/em&gt; of the solution. This is useful, for example, consider the task scheduling problem at the begining. The algorithm essentially minimizes the time to complete all tasks while satisfying all scheduling constraints.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maximize &lt;span class="math"&gt;\(\sum_{i=1}^n x_i\)&lt;/span&gt;&lt;/strong&gt; given addition constraints that &lt;span class="math"&gt;\(x_i \leq 0\)&lt;/span&gt; for all &lt;span class="math"&gt;\(i\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="further-reading"&gt;Further reading&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://courses.csail.mit.edu/6.006/spring11/lectures/lec17.pdf"&gt;MIT lecture notes&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Algorithm"></category><category term="graph"></category><category term="linear programming"></category></entry><entry><title>Binary Indexed Tree (Part 2)</title><link href="/binary-indexed-tree-part-2.html" rel="alternate"></link><published>2021-01-06T00:00:00+09:00</published><updated>2021-01-06T00:00:00+09:00</updated><author><name>Duong Nguyen</name></author><id>tag:None,2021-01-06:/binary-indexed-tree-part-2.html</id><summary type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Building on ideas from &lt;a href="https://ntduong.github.io/binary-indexed-tree-part-1.html"&gt;Part 1&lt;/a&gt;, in this part, we explore some lesser-known extensions and applications of BIT.&lt;/p&gt;
&lt;p&gt;This is by no means a finished post, and I'll keep updating whenever I find new BIT applications/extensions.&lt;/p&gt;
&lt;h1 id="variation-1-range-update-point-query"&gt;Variation 1: Range update, Point query&lt;/h1&gt;
&lt;p&gt;We want the data structure, which â€¦&lt;/p&gt;</summary><content type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Building on ideas from &lt;a href="https://ntduong.github.io/binary-indexed-tree-part-1.html"&gt;Part 1&lt;/a&gt;, in this part, we explore some lesser-known extensions and applications of BIT.&lt;/p&gt;
&lt;p&gt;This is by no means a finished post, and I'll keep updating whenever I find new BIT applications/extensions.&lt;/p&gt;
&lt;h1 id="variation-1-range-update-point-query"&gt;Variation 1: Range update, Point query&lt;/h1&gt;
&lt;p&gt;We want the data structure, which supports the following operations on an input array &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;range_update(L, R, v)&lt;/code&gt;: increase all &lt;span class="math"&gt;\(a[L..R]\)&lt;/span&gt; by &lt;span class="math"&gt;\(v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;point_query(i)&lt;/code&gt;: return the current &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Recall from Part 1, normal BIT only supports range prefix queries and point updates. How are we going to implement point query, range update with existing operations?&lt;/p&gt;
&lt;p&gt;Consider the diff array &lt;code&gt;d[1..n]&lt;/code&gt;, &lt;code&gt;d[1] = a[1], d[i] = a[i]-a[i-1]&lt;/code&gt; for &lt;code&gt;i=2,...,n&lt;/code&gt;,
&lt;code&gt;a[i] = d[i] + d[i-1] + ... + d[1]&lt;/code&gt; for &lt;code&gt;i=1,...,n&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key idea is to use the basic range query-point update BIT on the &lt;strong&gt;diff array &lt;span class="math"&gt;\(d[1..n]\)&lt;/span&gt;&lt;/strong&gt; instead of the original array &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Clearly, &lt;code&gt;query(i)&lt;/code&gt; = &lt;code&gt;sum(d[1..i])&lt;/code&gt; = &lt;code&gt;a[i]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now think about the range update &lt;code&gt;u(L,R,v)&lt;/code&gt;, &lt;span class="math"&gt;\(a[i] \leftarrow a[i]+v\)&lt;/span&gt; for all &lt;span class="math"&gt;\(L \leq i \leq R\)&lt;/span&gt;, how does the diff array change with the update?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No change to &lt;span class="math"&gt;\(d[i]\)&lt;/span&gt; for any &lt;span class="math"&gt;\(i &amp;lt; L\)&lt;/span&gt;, &lt;span class="math"&gt;\(L+1 \leq i \leq R\)&lt;/span&gt;, &lt;span class="math"&gt;\(R+1 &amp;lt; i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(d[L] \leftarrow d[L] + v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(d[R+1] \leftarrow d[R+1] - v\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus we can achieve the range update &lt;code&gt;u(L,R,v)&lt;/code&gt; with two point updates:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;update(L,v)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update(R+1,-v)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See also my &lt;a href="https://github.com/ntduong/Algorithms/blob/master/data_structures/range_queries/bit_variants.cpp#L18"&gt;reference implementation&lt;/a&gt; in C++ if you're interested.&lt;/p&gt;
&lt;h1 id="variation-2-range-update-range-query"&gt;Variation 2: Range update, Range query&lt;/h1&gt;
&lt;p&gt;We want the data structure, which supports the following operations on an input array &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;range_update(L, R, v)&lt;/code&gt;: increase all &lt;span class="math"&gt;\(a[L..R]\)&lt;/span&gt; by &lt;span class="math"&gt;\(v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;range_query(i)&lt;/code&gt;: return the prefix sum up to &lt;span class="math"&gt;\(i\)&lt;/span&gt;, i.e., &lt;span class="math"&gt;\(\sum_{j=1}^i a[j]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We've seen above how range update can be implemented. Let see how prefix range queries at different &lt;span class="math"&gt;\(i\)&lt;/span&gt;s change after a &lt;code&gt;range_update(L,R,v)&lt;/code&gt;, let denote the change to &lt;code&gt;sum(a[1..i])&lt;/code&gt; as &lt;span class="math"&gt;\(\delta(i)\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i &amp;lt; L\)&lt;/span&gt;, &lt;span class="math"&gt;\(\delta(i) = 0 = 0 * i - 0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(L \leq i \leq R\)&lt;/span&gt;, &lt;span class="math"&gt;\(\delta(i) = (i-L+1) * v = v * i - (L-1) * v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i &amp;gt; R\)&lt;/span&gt;, &lt;span class="math"&gt;\(\delta(i) = (R-L+1) * v = 0 * i + R * v - (L-1) * v = 0 * i - ((L-1) * v - R * v)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note &lt;span class="math"&gt;\(\delta(i) = b(i) * i - c(i)\)&lt;/span&gt;. We can use 2 range update/point query BITs (the variation 1 above) to implement the range query and range update. The first BIT computes &lt;span class="math"&gt;\(b(i)\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$
b(i) = \left\{\begin{array}{ll}
0 &amp;amp; \text{if}~i &amp;lt; L \\
v &amp;amp; \text{if}~L \leq i \leq R \\
0 &amp;amp; \text{otherwise}
\end{array}\right.
$$&lt;/div&gt;
&lt;p&gt;The second BIT computes &lt;span class="math"&gt;\(c(i)\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$
c(i) = \left\{\begin{array}{ll}
0 &amp;amp; \text{if}~i &amp;lt; L \\
(L-1)*v &amp;amp; \text{if}~L \leq i \leq R \\
(L-1)*v - R*v &amp;amp; \text{otherwise}
\end{array}\right.
$$&lt;/div&gt;
&lt;p&gt;&lt;code&gt;range_update(L,R,v)&lt;/code&gt; can be implemented as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# bit1&lt;/span&gt;
&lt;span class="n"&gt;bit1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;point_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;bit1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;point_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# bit2&lt;/span&gt;
&lt;span class="n"&gt;bit2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;point_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;bit2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;point_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Also,
&lt;code&gt;range_query(i) = bit1.query(i) * i - bit2.query(i)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;See also my &lt;a href="https://github.com/ntduong/Algorithms/blob/master/data_structures/range_queries/bit_variants.cpp#L68"&gt;reference implementation&lt;/a&gt; in C++ if you're interested.&lt;/p&gt;
&lt;h1 id="2d-bit"&gt;2D BIT&lt;/h1&gt;
&lt;p&gt;Consider a 2D grid of size &lt;span class="math"&gt;\(H \times W\)&lt;/span&gt;, we want to support the following operations on the grid in &lt;span class="math"&gt;\(O(\log H * \log W)\)&lt;/span&gt; time:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;point_update(r,c,v)&lt;/code&gt;: increase the &lt;span class="math"&gt;\(g[r][c]\)&lt;/span&gt; by &lt;span class="math"&gt;\(v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;range_query(r1,r2,c1,c2)&lt;/code&gt;: return sum of elements in &lt;span class="math"&gt;\(g[r1..r2][c1..c2]\)&lt;/span&gt;, &lt;span class="math"&gt;\(r1 \leq r2, c1 \leq c2\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you may expect, the &lt;code&gt;point_update&lt;/code&gt; is a straightforward extension of the normal 1D BIT into 2D. The range query can be computed as:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;range_query(r1,r2,c1,c2) = range_query(1,r2,1,c2) - range_query(1,r2,1,c1-1) - range_query(1,r1-1,1,c2) + range_query(1,r1-1,1,c1-1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;See also &lt;a href="https://github.com/ntduong/Algorithms/blob/master/data_structures/range_queries/bit2d.cpp"&gt;my reference implementation&lt;/a&gt; in C++.&lt;/p&gt;
&lt;h1 id="inversion-counting"&gt;Inversion Counting&lt;/h1&gt;
&lt;p&gt;&lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt; is a permutation of &lt;span class="math"&gt;\(\{1,2...n\}\)&lt;/span&gt;. An inversion is a pair &lt;span class="math"&gt;\((i,j)\)&lt;/span&gt;, &lt;span class="math"&gt;\(1 \leq i &amp;lt; j \leq n\)&lt;/span&gt; such that &lt;span class="math"&gt;\(a[i] &amp;gt; a[j]\)&lt;/span&gt;. Count the number of inversions in &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key idea is use the values &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; as index in BIT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Below is an overly commented Python snippet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;count_inversion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;initialize&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;BIT&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="n"&gt;bit&lt;/span&gt;

  &lt;span class="n"&gt;inv_cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# bit.query(x) returns how many values added so far, which are smaller than x.&lt;/span&gt;
    &lt;span class="c1"&gt;# Thus i - bit.query(x) is the number of values added which are bigger than x.&lt;/span&gt;
    &lt;span class="n"&gt;inv_cnt&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;# It&amp;#39;s important to update after the query.&lt;/span&gt;
    &lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inv_cnt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id="order-statistic-tree"&gt;Order Statistic Tree&lt;/h1&gt;
&lt;p&gt;We need a set-like data structure, which supports the following operations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add(x)&lt;/code&gt;: add &lt;span class="math"&gt;\(x\)&lt;/span&gt; to the set&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete(x)&lt;/code&gt;: remove &lt;span class="math"&gt;\(x\)&lt;/span&gt; from the set if existed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;order_of(x)&lt;/code&gt;: count the number of elements in the set that are strictly less than &lt;span class="math"&gt;\(x\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find_by_order(k)&lt;/code&gt;: return the &lt;span class="math"&gt;\(k^{th}\)&lt;/span&gt; lowest element in the set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Constraint: all updates &lt;span class="math"&gt;\(x\)&lt;/span&gt; are in the range &lt;span class="math"&gt;\([1..N]\)&lt;/span&gt; for some integer &lt;span class="math"&gt;\(N\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Again, the trick here is to use the element value as index in BIT array, making use of the constraint that all element values are in the range &lt;span class="math"&gt;\([1..N]\)&lt;/span&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Data structures"></category><category term="Algorithm"></category><category term="Fenwick tree"></category></entry><entry><title>Binary Indexed Tree (Part 1)</title><link href="/binary-indexed-tree-part-1.html" rel="alternate"></link><published>2021-01-05T00:00:00+09:00</published><updated>2021-01-05T00:00:00+09:00</updated><author><name>Duong Nguyen</name></author><id>tag:None,2021-01-05:/binary-indexed-tree-part-1.html</id><summary type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Binary indexed tree (BIT for short), aka &lt;a href="https://en.wikipedia.org/wiki/Fenwick_tree"&gt;Fenwick tree&lt;/a&gt;, is popular data structure in competitive programming (CP)context. I believe it could also be a valuable tool in practical software developers' toolbox. But is it worth yet another BIT tutorial? Yes as my aim is to provide a different â€¦&lt;/p&gt;</summary><content type="html">&lt;h1 id="motivation"&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Binary indexed tree (BIT for short), aka &lt;a href="https://en.wikipedia.org/wiki/Fenwick_tree"&gt;Fenwick tree&lt;/a&gt;, is popular data structure in competitive programming (CP)context. I believe it could also be a valuable tool in practical software developers' toolbox. But is it worth yet another BIT tutorial? Yes as my aim is to provide a different/new perspective on the data structure, complementing many existing (good) tutorials that I've seen. In particular, in this two-part series,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ntduong.github.io/binary-indexed-tree-part-1.html"&gt;Part 1&lt;/a&gt;: Distill its core ideas with intuitive explanation provided when needed. If you're already familiar with the standard range-query/point-update BIT, feel free to skip this part.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ntduong.github.io/binary-indexed-tree-part-2.html"&gt;Part 2&lt;/a&gt;: Building on the core ideas from Part 1, suggest some flexible (and probably lesser-known) ways to extend the data structure to support more usecases, such as range-update/range-query and high-dimensional range queries.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Last but not least, BIT is one of my all-time favorite data structure, and the underlying ideas are beautiful so I decided to write about it for my future self!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I've added &lt;a href="https://github.com/ntduong/Algorithms/tree/master/data_structures/range_queries"&gt;a reference C++ implementation&lt;/a&gt; for both parts on Github. Feel free to take a look and ignore non-BIT code there!&lt;/p&gt;
&lt;h2 id="what-is-bit-anyway"&gt;What is BIT anyway?&lt;/h2&gt;
&lt;p&gt;In short, BIT is a data structure, supporting efficient range queries on &lt;strong&gt;dynamic&lt;/strong&gt; arrays, i.e., the array content can be updated along the way. More concretely, a standard BIT supports the following operations on an sized-&lt;span class="math"&gt;\(n\)&lt;/span&gt; array &lt;span class="math"&gt;\(a[1..n]\)&lt;/span&gt; in &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; time per op, with additional &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; space (for internal structure):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prefix range query: &lt;span class="math"&gt;\(f(a[1..m])\)&lt;/span&gt;, e.g., sum of the first &lt;span class="math"&gt;\(m\)&lt;/span&gt; elements&lt;/li&gt;
&lt;li&gt;Point update: &lt;span class="math"&gt;\(u(a[i], v)\)&lt;/span&gt;, e.g., increasing &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; by &lt;span class="math"&gt;\(v\)&lt;/span&gt;, &lt;span class="math"&gt;\(a[i] \leftarrow a[i] + v\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are ways to enable (range update, point query) and (range update, range query) and they are all built on the key ideas that we're going to touch on later and in the next part.&lt;/p&gt;
&lt;p&gt;Despite its name and many existing tutorials describe it as a tree, I prefer to see BIT as a clever &lt;strong&gt;decomposition of the array&lt;/strong&gt; for efficient queries and updates. More about this will be discussed below.&lt;/p&gt;
&lt;p&gt;Honorable mentions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A more complex and powerful data structure which also support similar operations on dynamic arrays among other things is &lt;a href="https://cp-algorithms.com/data_structures/segment_tree.html"&gt;segment tree&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For range queries on &lt;strong&gt;static&lt;/strong&gt; arrays (no change to content), simpler data structures such as &lt;a href="https://cp-algorithms.com/data_structures/sparse-table.html"&gt;Sparse table&lt;/a&gt; (e.g., for range minimum query tasks), block decomposition techniques (e.g., &lt;a href="https://cp-algorithms.com/data_structures/sqrt_decomposition.html"&gt;square root decomposition&lt;/a&gt;), or even a simple prefix sum array would be enough.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'll write about these range-queries data structures in a future posts about beautiful and practical data structures (IMHO). So stay tuned!&lt;/p&gt;
&lt;h3 id="why-does-it-matter"&gt;Why does it matter?&lt;/h3&gt;
&lt;p&gt;Hang on, for the prefix range query and point update operations above, wouldn't the straightforward &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; update, &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; query on the array be enough? Why bother with BIT? Well, it depends, e.g.,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; update, &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; query approach is reasonable when most operations are update and very few are range query&lt;/li&gt;
&lt;li&gt;When the input size is large with many range queries then &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt; query isn't ideal and &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; query at the expense of &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; update seems better&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ClichÃ©: There is no single best solution for all usecases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="key-ideas"&gt;Key Ideas&lt;/h1&gt;
&lt;h2 id="range-decomposition"&gt;Range decomposition&lt;/h2&gt;
&lt;p&gt;For range query, without any preprocessing, the best we can do is to iterate over the whole range, which is essentially &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;. A natural idea is then to split the range into sub-ranges (smaller contiguous blocks) and "precompute" the queries on these blocks. To answer the query on the original range, we can just combine the precomputed answers on smaller sub-ranges.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key point is to devise efficient split and combine scheme.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Observation 1&lt;/strong&gt;: BIT splits a prefix range based on binary expansion.
Given a range &lt;span class="math"&gt;\(R = [1..m] = (0..m]\)&lt;/span&gt;, consider binary representation of &lt;span class="math"&gt;\(m = 2^{k_1} + 2^{k_2} + ... + 2^{k_t}\)&lt;/span&gt;, where &lt;span class="math"&gt;\(0 \leq k_1 \leq ... \leq k_t\)&lt;/span&gt;. Thus, 
&lt;/p&gt;
&lt;div class="math"&gt;$$
L = (0..2^{k_1}] \cup (2^{k_1}..(2^{k_1} + 2^{k_2})] \cup ...((2^{k_1}+...+2^{k_{t-1}})..m]
$$&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Clearly, all the subranges are disjoint and together (when union) they cover the whole original range.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;How do we quickly &lt;em&gt;traverse&lt;/em&gt; all these subranges?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Start with &lt;span class="math"&gt;\(m\)&lt;/span&gt; and remove the 1s to the right once at a time, starting from the least significant bit!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Example: &lt;span class="math"&gt;\(m = 7 = 2^2+2^1+2^0 = 111_{2}\)&lt;/span&gt;,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;remove the lsb: &lt;span class="math"&gt;\(7 (111) \rightarrow 6 (110)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;remove the next 1: &lt;span class="math"&gt;\(6 (110) \rightarrow 4(100)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;remove the last 1: &lt;span class="math"&gt;\(4(100) \rightarrow 0(000)\)&lt;/span&gt;
Hence, &lt;span class="math"&gt;\([1..7] = (0..7] = (0,4] \cup (4,6] \cup (6, 7]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The number of sub-ranges is the number of times the 1s are removed until we reach 0; which is the number of 1s in the binary representation of &lt;span class="math"&gt;\(m\)&lt;/span&gt;, which is at most &lt;span class="math"&gt;\(k_t \leq \log m\)&lt;/span&gt; (as &lt;span class="math"&gt;\(2^{k_t} \leq m\)&lt;/span&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can efficiently traverse and combine all the subranges of &lt;span class="math"&gt;\([1..n]\)&lt;/span&gt; in &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="remark"&gt;Remark&lt;/h3&gt;
&lt;p&gt;This &lt;strong&gt;binary expansion&lt;/strong&gt; (also known as &lt;strong&gt;binary lifting&lt;/strong&gt;) idea is so beautiful and I see it in many places (no surprise), such as RMQ (sparse table construction and non-idempotent query), finding lowest common ancestor (LCA), finding &lt;span class="math"&gt;\(k\)&lt;/span&gt;-node-away ancestor of a tree node, etc. For arrays of non-negatives (all prefix sums are non-decreasing), we can use this technique with BIT to find the prefix sum of a specific value in &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; time, same as binary search but no need for the array being sorted! I won't digress here and the binary lifting idea deserves its own post, for now see e.g., &lt;a href="https://codeforces.com/blog/entry/61364"&gt;this post&lt;/a&gt; if you're interested.&lt;/p&gt;
&lt;h3 id="implementation-details"&gt;Implementation details&lt;/h3&gt;
&lt;p&gt;Given a range &lt;span class="math"&gt;\((1..n]\)&lt;/span&gt;, it's fairly easy to implement the range query by iteratively extract and remove the least significant bit from &lt;span class="math"&gt;\(n\)&lt;/span&gt;. Recall modern computer system uses the &lt;a href="https://en.wikipedia.org/wiki/Two%27s_complement"&gt;two's conplement&lt;/a&gt; representation for integers, it's easy to see &lt;span class="math"&gt;\(2^{\text{lsb}(n)} = n \&amp;amp; (-n)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Let &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt; denote the query value computed on the range &lt;span class="math"&gt;\((i-(i\&amp;amp;-i)..i]\)&lt;/span&gt; (we'll get to how to update these &lt;span class="math"&gt;\(tree[1..n]\)&lt;/span&gt; later). In the code below, &lt;span class="math"&gt;\(tree[i] := sum(a[1..i])\)&lt;/span&gt; for prefix sum queries as an example, but the definition of &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt; is really problem-specific and we can adapt the logic to other kinds of query like &lt;span class="math"&gt;\(\text{xor}, \text{min}, \text{max}\)&lt;/span&gt;, etc when fitted. &lt;em&gt;Be creative!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Overly commented code snippet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;Returns sum(a[1..i]), 1 &amp;lt;= i &amp;lt;= n.&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

  &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# replace += with other combination ops for specific problems at hand&lt;/span&gt;
    &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="c1"&gt;# remove lsb to traverse to next subrange&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ans&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Generally, BIT only supports prefix range queries, but for specific cases such as range sum or xor we can query any range:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Range sum: &lt;span class="math"&gt;\(sum(a[L..R]) = query(R) - query(L-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Range XOR: &lt;span class="math"&gt;\(\text{xor}(a[L..R]) = query(R)~\text{xor}~ query(L-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="update-relevant-ranges"&gt;Update relevant ranges&lt;/h2&gt;
&lt;p&gt;We now get to point update operation, &lt;span class="math"&gt;\(u(a[i],v)\)&lt;/span&gt;. As mentioned above, &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt; stores the current value computed on its corresponding range &lt;span class="math"&gt;\((i-2^{\text{lsb}(i)}..i]\)&lt;/span&gt;. In other words, &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt; is responsible for the range&lt;span class="math"&gt;\( (i-2^{\text{lsb}(i)}..i]\)&lt;/span&gt;. Thus an update to any element in the range needs to "inform" and update &lt;span class="math"&gt;\(tree[i]\)&lt;/span&gt;. Flip it around, for an update &lt;span class="math"&gt;\(u(a[i], v),\)&lt;/span&gt; we need to update all relevant ranges to which &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; belongs!&lt;/p&gt;
&lt;p&gt;Denote &lt;span class="math"&gt;\(R_j = (j-2^{\text{lsb}(j)}..j]\)&lt;/span&gt;,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Claim 1: &lt;span class="math"&gt;\(R_i, R_{i+\text{lsb}(i)}...\)&lt;/span&gt; are the only ranges to which &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; belong.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For example, given array &lt;span class="math"&gt;\(a[1..8]\)&lt;/span&gt;, what ranges covering &lt;span class="math"&gt;\(a[3]\)&lt;/span&gt;?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(R_3 = (2..3]\)&lt;/span&gt;, &lt;span class="math"&gt;\(R_4 = (0..4]\)&lt;/span&gt;, &lt;span class="math"&gt;\(R_8 = (0..8]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Not convinced yet? Here is a proof sketch, which also gives some insights into the BIT structure.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma 1&lt;/strong&gt;: &lt;span class="math"&gt;\(R_i \subset R_{i+\text{lsb}(i)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Proof:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{lsb}(i) \leq 0 \Rightarrow j = i+\text{lsb}(i) \geq i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{lsb}(j) \geq \text{lsb}(i) +1 \Rightarrow 2^{\text{lsb}(j)} \geq 2*2^{\text{lsb}(i)} \Rightarrow j-2^{\text{lsb}(j)} \leq j-2*2^{\text{lsb}(i)} = i+2^{\text{lsb}(i)}-2*2^{\text{lsb}(i)} = i-2^{\text{lsb}(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lemma 1 shows that &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; belongs to &lt;span class="math"&gt;\(R_i, R_{i+\text{lsb}(i)}...\)&lt;/span&gt;. Next let see why these ranges are the only ones covering &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma 2&lt;/strong&gt;: For all &lt;span class="math"&gt;\(j\)&lt;/span&gt; such that &lt;span class="math"&gt;\(i &amp;lt; j &amp;lt; i+2^{\text{lsb}(i)}\)&lt;/span&gt;, &lt;span class="math"&gt;\(i \notin R_j\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Proof:&lt;/p&gt;
&lt;p&gt;Note that we only consider even &lt;span class="math"&gt;\(i\)&lt;/span&gt;, since for odd &lt;span class="math"&gt;\(i\)&lt;/span&gt;, &lt;span class="math"&gt;\(i+2^{\text{lsb}(i)} = i+1\)&lt;/span&gt;, and there is no integer &lt;span class="math"&gt;\(j \in (i,i+1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(j\)&lt;/span&gt; is odd, clearly &lt;span class="math"&gt;\(i \notin R_j = (j-1,j]\)&lt;/span&gt; since &lt;span class="math"&gt;\(i \leq j-1\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(j\)&lt;/span&gt; is even, &lt;span class="math"&gt;\(k = j-i\)&lt;/span&gt; is even, and &lt;span class="math"&gt;\(k &amp;lt; 2^{\text{lsb}(i)}\)&lt;/span&gt;, thus &lt;span class="math"&gt;\(2^{\text{lsb}(k)} &amp;lt; 2^{\text{lsb}(i)}\)&lt;/span&gt;. Hence, &lt;span class="math"&gt;\(\text{lsb}(k)\)&lt;/span&gt; is also &lt;span class="math"&gt;\(\text{lsb}(j)\)&lt;/span&gt;. &lt;span class="math"&gt;\(j-2^{\text{lsb}(j)} = j-2^{\text{lsb}(k)} \geq j-k = i\)&lt;/span&gt;, i.e., &lt;span class="math"&gt;\(i \notin R_j = (j-2^{\text{lsb}(j)}, j]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now apply Lemma 2 to &lt;span class="math"&gt;\(i' = i+\text{lsb}(i)\)&lt;/span&gt;, &lt;span class="math"&gt;\(\forall j \in (i', i' + \text{lsb}(i')\)&lt;/span&gt;, &lt;span class="math"&gt;\(i' \notin R_j\)&lt;/span&gt; and follows &lt;span class="math"&gt;\(i \notin R_j\)&lt;/span&gt; since &lt;span class="math"&gt;\(i &amp;lt; i'\)&lt;/span&gt;. Repeating this process, we can prove the claim that &lt;span class="math"&gt;\(R_i, R_{i+\text{lsb}(i)},...\)&lt;/span&gt; are the only ranges covering &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; (QED)!&lt;/p&gt;
&lt;h3 id="implementation-details_1"&gt;Implementation details&lt;/h3&gt;
&lt;p&gt;With the above claim, it's trivia to implement the update. As an example, this is the snippet for increment update &lt;span class="math"&gt;\(a[i] \leftarrow a[i] + v\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Claim 2: There is at most &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; ranges covering &lt;span class="math"&gt;\(a[i]\)&lt;/span&gt; for &lt;span class="math"&gt;\(1 \leq i \leq n\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The while loop continues until &lt;span class="math"&gt;\(i\)&lt;/span&gt; goes beyond &lt;span class="math"&gt;\(n\)&lt;/span&gt;. Every iteration update &lt;span class="math"&gt;\(i \leftarrow i + 2^{\text{lsb}(i)}\)&lt;/span&gt;, i.e., it moves the LSB at least one position to the left. Thus there can be at most &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; iterations, and the update op is &lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt; time, assuming the increment is &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h1 id="recap"&gt;Recap&lt;/h1&gt;
&lt;p&gt;In this part, we explore key ideas of BIT:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Split range into disjoint subranges based on binary expansion for efficient range query&lt;/li&gt;
&lt;li&gt;For each point update, we need to update all the ranges covering the point. This is a tradeoff to speed up the range query&lt;/li&gt;
&lt;li&gt;No single best solution for all usecases. BIT is efficient for large input size with a lot of range queries&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;https://cp-algorithms.com/data_structures/fenwick.html&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.topcoder.com/community/competitive-programming/tutorials/binary-indexed-trees/"&gt;Topcoder's excellent tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Data structures"></category><category term="Algorithm"></category><category term="Fenwick tree"></category></entry><entry><title>Reservoir Sampling</title><link href="/reservoir-sampling.html" rel="alternate"></link><published>2020-10-31T00:00:00+09:00</published><updated>2020-10-31T00:00:00+09:00</updated><author><name>Duong Nguyen</name></author><id>tag:None,2020-10-31:/reservoir-sampling.html</id><summary type="html">&lt;h1 id="getting-started"&gt;Getting started&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Reservoir_sampling"&gt;Reservoir sampling&lt;/a&gt; concerns with choosing &lt;span class="math"&gt;\(k\)&lt;/span&gt; items (i.e., a random sample of size &lt;span class="math"&gt;\(k\)&lt;/span&gt; or &lt;span class="math"&gt;\(k\)&lt;/span&gt;-sample for short) from a population of size &lt;span class="math"&gt;\(n\)&lt;/span&gt; (&lt;span class="math"&gt;\(n &amp;gt; k\)&lt;/span&gt;) without replacement such that each chosen item is selected randomly with &lt;em&gt;equal chance&lt;/em&gt; from the population. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1. What is the â€¦&lt;/strong&gt;&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;h1 id="getting-started"&gt;Getting started&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Reservoir_sampling"&gt;Reservoir sampling&lt;/a&gt; concerns with choosing &lt;span class="math"&gt;\(k\)&lt;/span&gt; items (i.e., a random sample of size &lt;span class="math"&gt;\(k\)&lt;/span&gt; or &lt;span class="math"&gt;\(k\)&lt;/span&gt;-sample for short) from a population of size &lt;span class="math"&gt;\(n\)&lt;/span&gt; (&lt;span class="math"&gt;\(n &amp;gt; k\)&lt;/span&gt;) without replacement such that each chosen item is selected randomly with &lt;em&gt;equal chance&lt;/em&gt; from the population. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1. What is the probability of an item being selected in the final k-sample?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consider an item &lt;span class="math"&gt;\(x\)&lt;/span&gt; from the population, let &lt;span class="math"&gt;\(P_i(x)\)&lt;/span&gt; denote the probability that &lt;span class="math"&gt;\(x\)&lt;/span&gt; is selected at the i-th round. 
&lt;/p&gt;
&lt;div class="math"&gt;$$P(x~\text{is selected}) = \sum_{i=1}^kP_i(x)$$&lt;/div&gt;
&lt;p&gt;As we sample without replacement, &lt;strong&gt;&lt;span class="math"&gt;\(x\)&lt;/span&gt; is selected at the i-th round&lt;/strong&gt; means &lt;span class="math"&gt;\(x\)&lt;/span&gt; &lt;strong&gt;isn't&lt;/strong&gt; selected in previous (i-1) rounds.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P_1(x) = \frac{1}{n}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P_2(x) = (1-P_1(x)) \times \frac{1}{n-1} = \frac{n-1}{n} \times \frac{1}{n-1} = \frac{1}{n}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P_3(x) = (1-P_1(x)-P_2(x)) \times \frac{1}{n-2} = \frac{1}{n}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\cdots\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P_k(x) = \frac{1}{n}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus, &lt;span class="math"&gt;\(P(x~\text{is selected}) = \frac{k}{n}\)&lt;/span&gt;.&lt;/p&gt;
&lt;h1 id="stream-setting"&gt;Stream setting&lt;/h1&gt;
&lt;p&gt;What if the population size is not known in advance as items coming in a stream (which may be infinite) and/or all items can't be stored in memory? Still the requirement is for a new coming item, the chance it is selected in the current sample should be equal to the chances of any item coming before, i.e., if we have seen &lt;span class="math"&gt;\(n\)&lt;/span&gt; items so far then the chance of a seen item being selected in the &lt;span class="math"&gt;\(k\)&lt;/span&gt;-sample is &lt;span class="math"&gt;\(k/n\)&lt;/span&gt;. The first &lt;span class="math"&gt;\(k\)&lt;/span&gt; items are always selected. Here comes the idea of sampling with adaptive probability, which I found very elegant!&lt;/p&gt;
&lt;h2 id="sampling-process"&gt;Sampling process&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keep the first &lt;span class="math"&gt;\(k\)&lt;/span&gt; items in our sample&lt;/li&gt;
&lt;li&gt;For the &lt;span class="math"&gt;\(i^{th}\)&lt;/span&gt; item (&lt;span class="math"&gt;\(i \geq k+1\)&lt;/span&gt;), select the item and thus replace an existing item in the current sample with it &lt;strong&gt;with probability &lt;span class="math"&gt;\(p = k/i\)&lt;/span&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="how-does-it-work"&gt;How does it work?&lt;/h2&gt;
&lt;p&gt;We can prove &lt;strong&gt;by induction&lt;/strong&gt; that at the &lt;span class="math"&gt;\(i^{th}\)&lt;/span&gt; round (&lt;span class="math"&gt;\(i \geq k+1\)&lt;/span&gt;), the probability that a seen item being selected is &lt;span class="math"&gt;\(k/i\)&lt;/span&gt;. Here is the sketch:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assume the claim is true at the round &lt;span class="math"&gt;\(i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The new item &lt;span class="math"&gt;\(x_{i+1}\)&lt;/span&gt; comes at the round &lt;span class="math"&gt;\(i+1\)&lt;/span&gt;, we select it into our current sample with &lt;span class="math"&gt;\(p = k/(i+1)\)&lt;/span&gt;. What is the probability &lt;span class="math"&gt;\(p(y)\)&lt;/span&gt; of an existing item &lt;span class="math"&gt;\(y\)&lt;/span&gt; (came in previous rounds) still being selected at this round?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;before this round, &lt;span class="math"&gt;\(p_{before}(y) = k/i\)&lt;/span&gt; per the induction assumption&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for &lt;span class="math"&gt;\(y\)&lt;/span&gt; still being selected, it needs to survive the round &lt;span class="math"&gt;\(i+1\)&lt;/span&gt;, which is one of the 2 following &lt;strong&gt;exclusive&lt;/strong&gt; cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(x_{i+1}\)&lt;/span&gt; is not selected: &lt;span class="math"&gt;\(p_1=(1-\frac{k}{i+1}) = \frac{i+1-k}{i+1}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(x_{i+1}\)&lt;/span&gt; is selected but it doesn't replace &lt;span class="math"&gt;\(y\)&lt;/span&gt;: &lt;span class="math"&gt;\(p_2=\frac{k}{i+1} \times \frac{k-1}{k} = \frac{k-1}{i+1}\)&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;thus, &lt;span class="math"&gt;\(p(y) = p_{before}(y) \times (p_1+p_2) = \frac{k}{i} \times \frac{i}{i+1} = k/(i+1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We just showed that claim is also true at the round &lt;span class="math"&gt;\(i+1\)&lt;/span&gt;. Hence the claim is true for all rounds thanks to the induction principle.&lt;/p&gt;
&lt;h2 id="implementation"&gt;Implementation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Add the first &lt;span class="math"&gt;\(k\)&lt;/span&gt; items to the sample list &lt;span class="math"&gt;\(L\)&lt;/span&gt; in coming order (1-based indexing)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Round &lt;span class="math"&gt;\(i\)&lt;/span&gt;: &lt;span class="math"&gt;\(x_i\)&lt;/span&gt; comes, draw a random integer &lt;span class="math"&gt;\(j \in [1,i]\)&lt;/span&gt;, e.g., &lt;code&gt;random.randint(1, i)&lt;/code&gt; in Python.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;span class="math"&gt;\(j &amp;lt;= k\)&lt;/span&gt;, replace L[j] with the current item &lt;span class="math"&gt;\(x_i\)&lt;/span&gt;, i.e., &lt;span class="math"&gt;\(L[j] := x_i\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;else skip the current item&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Algorithm"></category><category term="sampling"></category></entry><entry><title>Estimating Distribution Mean and Quantiles</title><link href="/estimating-distribution-mean-and-quantiles.html" rel="alternate"></link><published>2018-09-22T00:00:00+09:00</published><updated>2018-09-22T00:00:00+09:00</updated><author><name>Duong Nguyen</name></author><id>tag:None,2018-09-22:/estimating-distribution-mean-and-quantiles.html</id><summary type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In this note, we look into the problem of estimating various statistics such as mean, quantiles of an unknown distribution from its sample. &lt;/p&gt;
&lt;p&gt;More concretely, consider a univariate continuous random variable &lt;span class="math"&gt;\(X\)&lt;/span&gt; following an &lt;strong&gt;unknown&lt;/strong&gt; distribution with &lt;em&gt;probability density function&lt;/em&gt; (pdf) &lt;span class="math"&gt;\(p_X (x)\)&lt;/span&gt;. Given a sample set &lt;span class="math"&gt;\(\{x_i\}_ â€¦&lt;/span&gt;&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In this note, we look into the problem of estimating various statistics such as mean, quantiles of an unknown distribution from its sample. &lt;/p&gt;
&lt;p&gt;More concretely, consider a univariate continuous random variable &lt;span class="math"&gt;\(X\)&lt;/span&gt; following an &lt;strong&gt;unknown&lt;/strong&gt; distribution with &lt;em&gt;probability density function&lt;/em&gt; (pdf) &lt;span class="math"&gt;\(p_X (x)\)&lt;/span&gt;. Given a sample set &lt;span class="math"&gt;\(\{x_i\}_{i=1}^n\)&lt;/span&gt; drawn i.i.d from the distribution, estimate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The distribution mean (assume existence) &lt;span class="math"&gt;\(\mu = \mathbb{E}(X)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;The distribution quantiles (e.g., median), i.e., for a &lt;span class="math"&gt;\(\tau \in (0,1)\)&lt;/span&gt;, roughly speaking the smallest value &lt;span class="math"&gt;\(q_{\tau}\)&lt;/span&gt; such that &lt;span class="math"&gt;\(\textrm{Prob}(X \leq q_\tau) = \tau\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: I've tried to keep all the math below valid yet as simple as possible. Feel free to correct me if you find anything horribly wrong.&lt;/p&gt;
&lt;h1 id="the-mean"&gt;The mean&lt;/h1&gt;
&lt;p&gt;For an arbitrary &lt;span class="math"&gt;\(m \in \mathbb{R}\)&lt;/span&gt;, denote &lt;span class="math"&gt;\(\mathcal{L}(m) = \int (x-m)^2~p(x)~dx\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Claim 1&lt;/strong&gt;: &lt;span class="math"&gt;\(m^{*} = \underset{m}{\textrm{argmin}}~\mathcal{L}(m) = \mu\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Proof sketch&lt;/em&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{array}{rcl}
\underset{m}{\textrm{argmin}}~\mathcal{L}(m) &amp;amp;=&amp;amp;  \underset{m}{\textrm{argmin}} \left [\int m^2~p(x)~dx - \int 2mx~p(x)~dx \right ] \\
&amp;amp;=&amp;amp; \underset{m}{\textrm{argmin}} \left [m^2 - 2m\int x~p(x)~dx \right] \\
&amp;amp;=&amp;amp; \underset{m}{\textrm{argmin}}~\left (m - \int x~p(x)~dx\right )^2 = \int x~p(x)~dx = \mu
\end{array}
$$&lt;/div&gt;
&lt;h2 id="sample-estimate"&gt;Sample estimate&lt;/h2&gt;
&lt;p&gt;Since &lt;span class="math"&gt;\(p(x)\)&lt;/span&gt; is unknown, we instead minimize an approximate of the &lt;span class="math"&gt;\(\mathcal{L}(m)\)&lt;/span&gt; using the given sample, &lt;/p&gt;
&lt;div class="math"&gt;$$\hat{\mathcal{L}}(m) = \frac{1}{n} \sum_{i=1}^n (x_i - m)^2$$&lt;/div&gt;
&lt;p&gt; and obtain an estimate of the mean:
&lt;/p&gt;
&lt;div class="math"&gt;$$\hat{\mu} = \frac{1}{n} \sum_{i=1}^n~x_i =  \underset{m}{\textrm{argmin}}~\hat{\mathcal{L}}(m)$$&lt;/div&gt;
&lt;h1 id="the-median"&gt;The median&lt;/h1&gt;
&lt;p&gt;Let &lt;span class="math"&gt;\(F(x)\)&lt;/span&gt; denote the cumulative distribution, i.e., &lt;span class="math"&gt;\(F(x) = \textrm{Prob}(X \leq x)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;A median or &lt;span class="math"&gt;\(q_{0.5}\)&lt;/span&gt; is roughly the point which divides the distribution in half, i.e.,
&lt;/p&gt;
&lt;div class="math"&gt;$$F(q_{0.5}) = 0.5$$&lt;/div&gt;
&lt;p&gt;For an arbitrary &lt;span class="math"&gt;\(m \in \mathbb{R}\)&lt;/span&gt;, denote &lt;/p&gt;
&lt;div class="math"&gt;$$\mathcal{L}_{0.5} (m) = \int |x-m|~p(x)~dx$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Claim 2&lt;/strong&gt;: &lt;span class="math"&gt;\(m^{*} = \underset{m}{\textrm{argmin}}~\mathcal{L}_{0.5}(m) = q_{0.5}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;See the next section for a proof sketch of a general case of any quantile &lt;span class="math"&gt;\(\tau \in (0,1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="sample-estimate_1"&gt;Sample estimate&lt;/h2&gt;
&lt;p&gt;Similar to the mean estimate, we can obtain an estimate of the median from the given sample,
&lt;/p&gt;
&lt;div class="math"&gt;$$\hat{q}_{0.5} = \underset{m}{\textrm{argmin}}~\frac{1}{n} \sum_{i=1}^n |x_i-m| = \textrm{median}(\{x_i\}_{i=1}^n)$$&lt;/div&gt;
&lt;h1 id="the-tau-quantile"&gt;The &lt;span class="math"&gt;\(\tau\)&lt;/span&gt;-quantile&lt;/h1&gt;
&lt;p&gt;For an arbitrary &lt;span class="math"&gt;\(m \in \mathbb{R}\)&lt;/span&gt;, denote
&lt;/p&gt;
&lt;div class="math"&gt;$$\mathcal{L}_{\tau}(m) = \int (x-m)(\tau - 1_{x &amp;lt; m})~p(x)~dx$$&lt;/div&gt;
&lt;p&gt;
where &lt;/p&gt;
&lt;div class="math"&gt;$$
1_{x &amp;lt; m} = \left\{\begin{array}{ll}
1 &amp;amp; \text{if}~x &amp;lt; m \\
0 &amp;amp; \text{otherwise}
\end{array}\right.
$$&lt;/div&gt;
&lt;p&gt;Note that &lt;span class="math"&gt;\((x-m)(\tau - 1_{x &amp;lt; m})\)&lt;/span&gt; is nothing other than the &lt;strong&gt;quantile loss&lt;/strong&gt; often used in &lt;a href="https://en.wikipedia.org/wiki/Quantile_regression"&gt;quantile regression&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Claim 3&lt;/strong&gt;: &lt;span class="math"&gt;\(m^{*} = \underset{m}{\textrm{argmin}}~\mathcal{L}_\tau (m) = q_{\tau}\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id="derivation-of-the-quantile-loss"&gt;Derivation of the quantile loss&lt;/h2&gt;
&lt;p&gt;Curious readers may wonder how to come up with the above formula of &lt;span class="math"&gt;\(\mathcal{L}_{\tau}(m)\)&lt;/span&gt;. Let's &lt;em&gt;reverse-engineer&lt;/em&gt; the quantile loss.&lt;/p&gt;
&lt;p&gt;Given arbitrary &lt;span class="math"&gt;\(0 &amp;lt; c_1, c_2 \in \mathbb{R}\)&lt;/span&gt;, consider a generalized form of the median loss &lt;span class="math"&gt;\(\mathcal{L}_{0.5}\)&lt;/span&gt;, 
&lt;/p&gt;
&lt;div class="math"&gt;$$\mathcal{L}_{c_1, c_2}(m) = c_1 \underset{x \geq m}{\int} (x-m)~p(x)~dx + c_2 \underset{x &amp;lt; m}{\int} (m-x)~p(x)~dx$$&lt;/div&gt;
&lt;p&gt;
Intuitively, we assign different &lt;em&gt;costs&lt;/em&gt; to &lt;span class="math"&gt;\(x\)&lt;/span&gt; depending on its value relative to &lt;span class="math"&gt;\(m\)&lt;/span&gt;. The problem is for a given &lt;span class="math"&gt;\(\tau \in (0,1)\)&lt;/span&gt; find &lt;span class="math"&gt;\(c_1, c_2\)&lt;/span&gt; such that
&lt;/p&gt;
&lt;div class="math"&gt;$$\underset{m}{\textrm{argmin}}~\mathcal{L}_{c_1, c_2}(m) = q_\tau$$&lt;/div&gt;
&lt;p&gt;Take a variable change &lt;span class="math"&gt;\(u=F(x)\)&lt;/span&gt; then &lt;span class="math"&gt;\(du = dF(x) = p(x)~dx\)&lt;/span&gt; and &lt;span class="math"&gt;\(F(m) = v\)&lt;/span&gt; for some &lt;span class="math"&gt;\(v \in [0,1]\)&lt;/span&gt;. Also, &lt;span class="math"&gt;\(x = F^{-1}(u)\)&lt;/span&gt;. Note that &lt;strong&gt;we slightly abuse the notation here using &lt;span class="math"&gt;\(\mathcal{L}_{c_1, c_2}(v)\)&lt;/span&gt; as the loss after the variable change to avoid introducing new notation.&lt;/strong&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{array}{lcl}
\mathcal{L}_{c_1, c_2}(v) &amp;amp;=&amp;amp; c_1\int_v^1(F^{-1}(u)-F^{-1}(v))~du + c_2\int_0^v(F^{-1}(v)-F^{-1}(u))~du \\
&amp;amp;=&amp;amp; c_1\int_v^1 F^{-1}(u)~du - c_1 F^{-1}(v) (1-v) + c_2 F^{-1}(v) v - c_2\int_0^v F^{-1}(u)~du
\end{array}
$$&lt;/div&gt;
&lt;p&gt;From the &lt;a href="https://en.wikipedia.org/wiki/Leibniz_integral_rule"&gt;Leibniz integral rule&lt;/a&gt; and the &lt;a href="https://en.wikipedia.org/wiki/Product_rule"&gt;product rule&lt;/a&gt;,&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{array}{lcl}
\frac{d}{dv}\mathcal{L}_{c_1, c_2}(v) &amp;amp; = &amp;amp; -c_1 F^{-1}(v) + c_1 F^{-1}(v) - c_1 (1-v)\frac{d}{dv}F^{-1}(v) \\ &amp;amp; &amp;amp; +~c_2 F^{-1}(v) + c_2 v\frac{d}{dv}F^{-1}(v) - c_2 F^{-1}(v) \\
&amp;amp; = &amp;amp; \frac{d}{dv}F^{-1}(v) (-c_1 + c_1 v + c_2 v)~~(*)
\end{array}
$$&lt;/div&gt;
&lt;p&gt;For &lt;span class="math"&gt;\(q_\tau\)&lt;/span&gt; to be the minimizer of &lt;span class="math"&gt;\(\mathcal{L}_{c_1, c_2}(m)\)&lt;/span&gt;, or equivalently, &lt;span class="math"&gt;\(\tau\)&lt;/span&gt; is the minimizer of &lt;span class="math"&gt;\(\mathcal{L}_{c_1, c_2}(v)\)&lt;/span&gt;,
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{d}{dv}\mathcal{L}_{c_1, c_2}(v)_{\mid v=\tau} = 0,$$&lt;/div&gt;
&lt;p&gt; 
and since &lt;span class="math"&gt;\(\frac{d}{dv}F^{-1}(v) \neq 0\)&lt;/span&gt; in general, this essentially implies &lt;/p&gt;
&lt;div class="math"&gt;$$c_1 \tau + c_2 \tau - c_1 = 0$$&lt;/div&gt;
&lt;p&gt;Note that the loss minimizer doesn't change if we scale &lt;span class="math"&gt;\(c_1, c_2\)&lt;/span&gt; with the same rate, so without the loss of generality, we can set &lt;span class="math"&gt;\(c_1 = 1\)&lt;/span&gt;. Thus solving for &lt;span class="math"&gt;\(c_2\)&lt;/span&gt;, we obtain &lt;span class="math"&gt;\(c_2 = \frac{1-\tau}{\tau}\)&lt;/span&gt;. Substitute &lt;span class="math"&gt;\(c_1 = 1, c_2 = \frac{1-\tau}{\tau}\)&lt;/span&gt; into the original loss:
&lt;/p&gt;
&lt;div class="math"&gt;$$\mathcal{L}_{c_1, c_2}(m) = \underset{x \geq m}{\int} (x-m)~p(x)~dx + \frac{1-\tau}{\tau}\underset{x &amp;lt; m}{\int} (m-x)~p(x)~dx$$&lt;/div&gt;
&lt;p&gt;
Since &lt;span class="math"&gt;\(\tau &amp;gt; 0\)&lt;/span&gt;, minimizing &lt;span class="math"&gt;\(\mathcal{L}_{c_1, c_2}(m)\)&lt;/span&gt; is equivalent to minimizing the following:
&lt;/p&gt;
&lt;div class="math"&gt;$$\tau\underset{x \geq m}{\int} (x-m)~p(x)~dx + (1-\tau)\underset{x &amp;lt; m}{\int} (m-x)~p(x)~dx$$&lt;/div&gt;
&lt;p&gt;
which is the same as &lt;/p&gt;
&lt;div class="math"&gt;$$\mathcal{L}_{\tau}(m) = \int (x-m)(\tau - 1_{x &amp;lt; m})~p(x)~dx$$&lt;/div&gt;
&lt;h2 id="why-q_tau-is-the-minimizer-of-mathcall_taum"&gt;Why &lt;span class="math"&gt;\(q_\tau\)&lt;/span&gt; is the minimizer of &lt;span class="math"&gt;\(\mathcal{L}_{\tau}(m)\)&lt;/span&gt;?&lt;/h2&gt;
&lt;p&gt;As shown above, &lt;span class="math"&gt;\(\tau\)&lt;/span&gt; is a critical point of &lt;span class="math"&gt;\(\mathcal{L}_{\tau}(v)\)&lt;/span&gt;,
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{d}{dv}\mathcal{L}_{\tau}(v)_{\mid v=\tau} = 0$$&lt;/div&gt;
&lt;p&gt;From &lt;span class="math"&gt;\((*)\)&lt;/span&gt; with &lt;span class="math"&gt;\(c_1 = \tau, c_2 = 1 - \tau\)&lt;/span&gt;, we have &lt;span class="math"&gt;\(\frac{d}{dv}\mathcal{L}_{\tau}(v) =   \frac{d}{dv}F^{-1}(v) (v - \tau)\)&lt;/span&gt;. Since &lt;span class="math"&gt;\(F^{-1}\)&lt;/span&gt; is a non-decreasing function, i.e., for any &lt;span class="math"&gt;\(0 \leq v_1 \leq v_2 \leq 1\)&lt;/span&gt;, &lt;span class="math"&gt;\(F^{-1}(v_1) \leq F^{-1}(v_2)\)&lt;/span&gt;; so &lt;span class="math"&gt;\(\frac{d}{dv}F^{-1}(v) &amp;gt; 0\)&lt;/span&gt;. Thus, &lt;span class="math"&gt;\(\frac{d}{dv}\mathcal{L}_{\tau}(v)\)&lt;/span&gt; has the same sign as &lt;span class="math"&gt;\(v - \tau\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For any &lt;span class="math"&gt;\(v \geq \tau\)&lt;/span&gt;, &lt;span class="math"&gt;\(\frac{d}{dv}\mathcal{L}_{\tau}(v) \geq 0\)&lt;/span&gt;; hence &lt;span class="math"&gt;\(\mathcal{L}_{\tau}(v) \geq \mathcal{L}_{\tau}(\tau)\)&lt;/span&gt;. &lt;/li&gt;
&lt;li&gt;For any &lt;span class="math"&gt;\(v \leq \tau\)&lt;/span&gt;, &lt;span class="math"&gt;\(\frac{d}{dv}\mathcal{L}_{\tau}(v) \leq 0\)&lt;/span&gt;; hence &lt;span class="math"&gt;\(\mathcal{L}_{\tau}(v) \geq \mathcal{L}_{\tau}(\tau)\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For any &lt;span class="math"&gt;\(v \in [0,1]\)&lt;/span&gt;, &lt;span class="math"&gt;\(\mathcal{L}_{\tau}(v) \geq \mathcal{L}_{\tau}(\tau)\)&lt;/span&gt;. Thus &lt;span class="math"&gt;\(\tau\)&lt;/span&gt; is a minimizer of &lt;span class="math"&gt;\(\mathcal{L}_{\tau}(v)\)&lt;/span&gt;, or equivalently &lt;span class="math"&gt;\(q_\tau\)&lt;/span&gt; is a minimizer of &lt;span class="math"&gt;\(\mathcal{L}_{\tau}(m)\)&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="sample-estimate_2"&gt;Sample estimate&lt;/h2&gt;
&lt;p&gt;Finally, we can obtain an estimate of the quantile as:&lt;/p&gt;
&lt;div class="math"&gt;$$\hat{q}_{\tau} = \underset{m}{\textrm{argmin}}~\frac{1}{n} \sum_{i=1}^n (x_i-m)(\tau - 1_{x_i &amp;lt; m})$$&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Stats"></category><category term="distribution"></category><category term="mean"></category><category term="median"></category><category term="quantile"></category><category term="estimate"></category></entry></feed>